{"ast":null,"code":"var _jsxFileName = \"/home/agreus/Documents/webdev/mercury-messenger/client/src/utils/iterableComponents.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$(),\n  _s3 = $RefreshSig$(),\n  _s4 = $RefreshSig$(),\n  _s5 = $RefreshSig$(),\n  _s6 = $RefreshSig$();\nimport { useContext } from \"react\";\nimport { DataContext } from \"../components/context/DataContext\";\nimport { FlashContext } from \"../components/context/FlashContext\";\nimport Sender from \"../components/chat/SenderWrapper\";\nimport Message from \"../components/chat/Message\";\nimport GroupBadge from \"../components/groups/GroupBadge\";\nimport ChannelBadge from \"../components/channels/ChannelBadge\";\nimport MemberStatusBadge from \"../components/channels/MemberStatusBadge\";\nimport { FlashMessageWrapper, FlashMessage } from \"../components/ui/FlashMessage\";\n\n// utility hooks\nimport useSocket from \"./socket\";\nimport SelectableMemberBadge from \"../components/ui/SelectableMemberBadge\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport function FlashStack() {\n  _s();\n  const {\n    messageStack,\n    unmountFlash\n  } = useContext(FlashContext);\n  const stack = [];\n  messageStack === null || messageStack === void 0 ? void 0 : messageStack.forEach(message => {\n    const position = messageStack.indexOf(message);\n    stack.push( /*#__PURE__*/_jsxDEV(FlashMessage, {\n      type: message.type,\n      message: message.message,\n      position: position,\n      unmount: unmountFlash\n    }, position, false, {\n      fileName: _jsxFileName,\n      lineNumber: 28,\n      columnNumber: 7\n    }, this));\n  });\n  return /*#__PURE__*/_jsxDEV(FlashMessageWrapper, {\n    children: stack\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 38,\n    columnNumber: 10\n  }, this);\n}\n_s(FlashStack, \"vZTj6SUQceLPjoaFILsKIYqxPio=\");\n_c = FlashStack;\nexport function GroupStack() {\n  _s2();\n  const {\n    groupData,\n    selectedGroup,\n    setSelectedGroup,\n    setSelectedChannel,\n    dataHelpers\n  } = useContext(DataContext);\n  function groupChangeHandler(groupId) {\n    setSelectedGroup(groupData[groupId]);\n    setSelectedChannel(null);\n  }\n  const groupStack = [];\n  for (const groupId in groupData) {\n    const thisGroup = groupData[groupId];\n    const selected = groupId === (selectedGroup === null || selectedGroup === void 0 ? void 0 : selectedGroup._id);\n    groupStack.push( /*#__PURE__*/_jsxDEV(GroupBadge, {\n      name: thisGroup.name,\n      img: thisGroup.image.thumbnail,\n      selected: selected,\n      unread: dataHelpers.getUnread({\n        groupId\n      }),\n      onClick: () => groupChangeHandler(thisGroup._id)\n    }, thisGroup._id, false, {\n      fileName: _jsxFileName,\n      lineNumber: 62,\n      columnNumber: 7\n    }, this));\n  }\n  return groupStack;\n}\n_s2(GroupStack, \"FjU7XrKh5tQIkMoqbeDf5g70lZE=\");\n_c2 = GroupStack;\nexport function ChannelStack() {\n  _s3();\n  const {\n    groupData,\n    selectedGroup,\n    selectedChannel,\n    dataHelpers\n  } = useContext(DataContext);\n  const thisGroup = groupData[selectedGroup._id];\n  const isAdmin = thisGroup.administrators.some(admin => admin._id === localStorage.userId);\n  const channelStack = [];\n  thisGroup.channels.text.forEach(channel => {\n    const selected = (selectedChannel === null || selectedChannel === void 0 ? void 0 : selectedChannel._id) === channel._id ? true : false;\n    channelStack.push( /*#__PURE__*/_jsxDEV(ChannelBadge, {\n      data: channel,\n      selected: selected,\n      type: \"text\",\n      unread: dataHelpers.getUnread({\n        channelId: channel._id\n      }),\n      isAdmin: isAdmin\n    }, channel._id, false, {\n      fileName: _jsxFileName,\n      lineNumber: 91,\n      columnNumber: 7\n    }, this));\n  });\n  return channelStack;\n}\n_s3(ChannelStack, \"CP9pfgFzYmhj7pvtUm7oGwcZY6M=\");\n_c3 = ChannelStack;\nexport function MemberStatusStack() {\n  _s4();\n  const {\n    groupData,\n    selectedGroup\n  } = useContext(DataContext);\n  const {\n    peerHelpers\n  } = useContext(DataContext);\n  const thisGroup = groupData[selectedGroup._id];\n  const memberStack = [];\n  thisGroup.members.forEach(member => {\n    memberStack.push( /*#__PURE__*/_jsxDEV(MemberStatusBadge, {\n      member: member,\n      status: peerHelpers.getStatus(member._id),\n      isAdmin: true\n    }, member._id, false, {\n      fileName: _jsxFileName,\n      lineNumber: 114,\n      columnNumber: 7\n    }, this));\n  });\n  return memberStack;\n}\n_s4(MemberStatusStack, \"aGAV1ek2gEZxbFrahe41Qu29fYY=\");\n_c4 = MemberStatusStack;\nexport function MentionsSelector(props) {\n  _s5();\n  const {\n    selectedMembers,\n    onSelect,\n    onDeselect\n  } = props;\n  const {\n    groupData,\n    selectedGroup\n  } = useContext(DataContext);\n  const thisGroup = groupData[selectedGroup._id];\n  const memberStack = [];\n  function toggleSelection(userId) {\n    if (!selectedMembers.includes(userId)) onSelect(userId);else onDeselect(userId);\n  }\n  thisGroup.members.forEach(member => {\n    if (member._id === localStorage.userId) return null; // don't render this user\n\n    const selected = selectedMembers.includes(member._id);\n    memberStack.push( /*#__PURE__*/_jsxDEV(SelectableMemberBadge, {\n      member: member,\n      selected: selected,\n      onClick: toggleSelection\n    }, member._id, false, {\n      fileName: _jsxFileName,\n      lineNumber: 143,\n      columnNumber: 7\n    }, this));\n  });\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"w-full h-full overflow-x-hidden overflow-y-auto scrollbar-dark\",\n    children: memberStack\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 153,\n    columnNumber: 5\n  }, this);\n}\n\n// renders every cluster in the current chat\n_s5(MentionsSelector, \"I+qLo1v9S7M/8cN0ua5SRGVAtDQ=\");\n_c5 = MentionsSelector;\nexport function ChatStack() {\n  _s6();\n  const {\n    groupData,\n    selectedGroup,\n    selectedChannel,\n    dataHelpers\n  } = useContext(DataContext);\n  const {\n    sendMessage,\n    appendMessage\n  } = useSocket();\n  const thisGroup = groupData[selectedGroup._id];\n  const chatData = thisGroup.chatData[selectedChannel._id];\n  const clusterStack = [];\n  const isUserAdmin = {};\n  thisGroup.members.forEach(member => {\n    const isAdmin = thisGroup.administrators.some(admin => admin._id === member._id);\n    isUserAdmin[member._id] = isAdmin ? true : false;\n  });\n\n  // renders the sender/cluster wrapper\n  function renderMessages(cluster) {\n    const content = cluster.content;\n    const messageStack = [];\n    const someFailed = content.some(message => message === null || message === void 0 ? void 0 : message.failed);\n    const allConfirmed = content.every(message => (message === null || message === void 0 ? void 0 : message.failed) || message._id); // prevent retry actions if some messages are still pending\n    let isGenesis = true;\n    let retryObject = null;\n\n    // creates object with all necessary information for a retry if any failed\n    if (someFailed && allConfirmed) {\n      retryObject = {\n        clusterData: cluster,\n        actions: {\n          sendMessage,\n          appendMessage,\n          removeClusterLocally: dataHelpers.removeClusterLocally\n        },\n        chatLocation: {\n          group: selectedGroup._id,\n          channel: selectedChannel._id\n        },\n        failedIndex: content.reduce((result, message, index) => {\n          if (message.failed) result.push(index);\n          return result;\n        }, [])\n      };\n    }\n\n    // renders the individual messages in the cluster\n    content.forEach(message => {\n      // some messages can be null if saved out of order, so check\n      if (message) {\n        messageStack.push( /*#__PURE__*/_jsxDEV(Message, {\n          text: message.text,\n          image: message.file,\n          pending: message._id ? false : true,\n          failed: message.failed // indicates fails on messages\n          ,\n          retryObject: isGenesis ? retryObject : null // enables retry actions on genesis message if any child failed\n        }, message.timestamp, false, {\n          fileName: _jsxFileName,\n          lineNumber: 214,\n          columnNumber: 11\n        }, this));\n      }\n      if (isGenesis) isGenesis = false;\n    });\n    return messageStack;\n  }\n  chatData.forEach(cluster => {\n    clusterStack.push( /*#__PURE__*/_jsxDEV(Sender, {\n      clusterId: cluster._id,\n      sender: cluster.sender,\n      timestamp: cluster.clusterTimestamp,\n      pending: cluster._id ? false : true,\n      mentions: cluster.mentions,\n      reply: cluster.reply,\n      children: renderMessages(cluster)\n    }, cluster.clusterTimestamp, false, {\n      fileName: _jsxFileName,\n      lineNumber: 232,\n      columnNumber: 7\n    }, this));\n  });\n  return clusterStack;\n}\n_s6(ChatStack, \"RvSW+7cxdLSbCaV77WNvKg89ETs=\", false, function () {\n  return [useSocket];\n});\n_c6 = ChatStack;\nvar _c, _c2, _c3, _c4, _c5, _c6;\n$RefreshReg$(_c, \"FlashStack\");\n$RefreshReg$(_c2, \"GroupStack\");\n$RefreshReg$(_c3, \"ChannelStack\");\n$RefreshReg$(_c4, \"MemberStatusStack\");\n$RefreshReg$(_c5, \"MentionsSelector\");\n$RefreshReg$(_c6, \"ChatStack\");","map":{"version":3,"names":["useContext","DataContext","FlashContext","Sender","Message","GroupBadge","ChannelBadge","MemberStatusBadge","FlashMessageWrapper","FlashMessage","useSocket","SelectableMemberBadge","FlashStack","messageStack","unmountFlash","stack","forEach","message","position","indexOf","push","type","GroupStack","groupData","selectedGroup","setSelectedGroup","setSelectedChannel","dataHelpers","groupChangeHandler","groupId","groupStack","thisGroup","selected","_id","name","image","thumbnail","getUnread","ChannelStack","selectedChannel","isAdmin","administrators","some","admin","localStorage","userId","channelStack","channels","text","channel","channelId","MemberStatusStack","peerHelpers","memberStack","members","member","getStatus","MentionsSelector","props","selectedMembers","onSelect","onDeselect","toggleSelection","includes","ChatStack","sendMessage","appendMessage","chatData","clusterStack","isUserAdmin","renderMessages","cluster","content","someFailed","failed","allConfirmed","every","isGenesis","retryObject","clusterData","actions","removeClusterLocally","chatLocation","group","failedIndex","reduce","result","index","file","timestamp","sender","clusterTimestamp","mentions","reply"],"sources":["/home/agreus/Documents/webdev/mercury-messenger/client/src/utils/iterableComponents.js"],"sourcesContent":["import { useContext } from \"react\";\n\nimport { DataContext } from \"../components/context/DataContext\";\nimport { FlashContext } from \"../components/context/FlashContext\";\n\nimport Sender from \"../components/chat/SenderWrapper\";\nimport Message from \"../components/chat/Message\";\nimport GroupBadge from \"../components/groups/GroupBadge\";\nimport ChannelBadge from \"../components/channels/ChannelBadge\";\nimport MemberStatusBadge from \"../components/channels/MemberStatusBadge\";\nimport {\n  FlashMessageWrapper,\n  FlashMessage,\n} from \"../components/ui/FlashMessage\";\n\n// utility hooks\nimport useSocket from \"./socket\";\nimport SelectableMemberBadge from \"../components/ui/SelectableMemberBadge\";\n\nexport function FlashStack() {\n  const { messageStack, unmountFlash } = useContext(FlashContext);\n  const stack = [];\n\n  messageStack?.forEach((message) => {\n    const position = messageStack.indexOf(message);\n\n    stack.push(\n      <FlashMessage\n        type={message.type}\n        message={message.message}\n        key={position}\n        position={position}\n        unmount={unmountFlash}\n      />\n    );\n  });\n\n  return <FlashMessageWrapper>{stack}</FlashMessageWrapper>;\n}\n\nexport function GroupStack() {\n  const {\n    groupData,\n    selectedGroup,\n    setSelectedGroup,\n    setSelectedChannel,\n    dataHelpers,\n  } = useContext(DataContext);\n\n  function groupChangeHandler(groupId) {\n    setSelectedGroup(groupData[groupId]);\n    setSelectedChannel(null);\n  }\n\n  const groupStack = [];\n\n  for (const groupId in groupData) {\n    const thisGroup = groupData[groupId];\n    const selected = groupId === selectedGroup?._id;\n\n    groupStack.push(\n      <GroupBadge\n        name={thisGroup.name}\n        img={thisGroup.image.thumbnail}\n        selected={selected}\n        unread={dataHelpers.getUnread({ groupId })}\n        key={thisGroup._id}\n        onClick={() => groupChangeHandler(thisGroup._id)}\n      />\n    );\n  }\n  return groupStack;\n}\n\nexport function ChannelStack() {\n  const { groupData, selectedGroup, selectedChannel, dataHelpers } =\n    useContext(DataContext);\n\n  const thisGroup = groupData[selectedGroup._id];\n\n  const isAdmin = thisGroup.administrators.some(\n    (admin) => admin._id === localStorage.userId\n  );\n\n  const channelStack = [];\n\n  thisGroup.channels.text.forEach((channel) => {\n    const selected = selectedChannel?._id === channel._id ? true : false;\n\n    channelStack.push(\n      <ChannelBadge\n        data={channel}\n        selected={selected}\n        type=\"text\"\n        unread={dataHelpers.getUnread({ channelId: channel._id })}\n        key={channel._id}\n        isAdmin={isAdmin}\n      />\n    );\n  });\n\n  return channelStack;\n}\n\nexport function MemberStatusStack() {\n  const { groupData, selectedGroup } = useContext(DataContext);\n  const { peerHelpers } = useContext(DataContext);\n\n  const thisGroup = groupData[selectedGroup._id];\n  const memberStack = [];\n\n  thisGroup.members.forEach((member) => {\n    memberStack.push(\n      <MemberStatusBadge\n        member={member}\n        status={peerHelpers.getStatus(member._id)}\n        key={member._id}\n        isAdmin={true}\n      />\n    );\n  });\n  return memberStack;\n}\n\nexport function MentionsSelector(props) {\n  const { selectedMembers, onSelect, onDeselect } = props;\n  const { groupData, selectedGroup } = useContext(DataContext);\n\n  const thisGroup = groupData[selectedGroup._id];\n  const memberStack = [];\n\n  function toggleSelection(userId) {\n    if (!selectedMembers.includes(userId)) onSelect(userId);\n    else onDeselect(userId);\n  }\n\n  thisGroup.members.forEach((member) => {\n    if (member._id === localStorage.userId) return null; // don't render this user\n\n    const selected = selectedMembers.includes(member._id);\n\n    memberStack.push(\n      <SelectableMemberBadge\n        member={member}\n        key={member._id}\n        selected={selected}\n        onClick={toggleSelection}\n      />\n    );\n  });\n\n  return (\n    <div className=\"w-full h-full overflow-x-hidden overflow-y-auto scrollbar-dark\">\n      {memberStack}\n    </div>\n  );\n}\n\n// renders every cluster in the current chat\nexport function ChatStack() {\n  const { groupData, selectedGroup, selectedChannel, dataHelpers } =\n    useContext(DataContext);\n  const { sendMessage, appendMessage } = useSocket();\n\n  const thisGroup = groupData[selectedGroup._id];\n  const chatData = thisGroup.chatData[selectedChannel._id];\n\n  const clusterStack = [];\n  const isUserAdmin = {};\n\n  thisGroup.members.forEach((member) => {\n    const isAdmin = thisGroup.administrators.some(\n      (admin) => admin._id === member._id\n    );\n    isUserAdmin[member._id] = isAdmin ? true : false;\n  });\n\n  // renders the sender/cluster wrapper\n  function renderMessages(cluster) {\n    const content = cluster.content;\n    const messageStack = [];\n    const someFailed = content.some((message) => message?.failed);\n    const allConfirmed = content.every(\n      (message) => message?.failed || message._id\n    ); // prevent retry actions if some messages are still pending\n    let isGenesis = true;\n    let retryObject = null;\n\n    // creates object with all necessary information for a retry if any failed\n    if (someFailed && allConfirmed) {\n      retryObject = {\n        clusterData: cluster,\n        actions: {\n          sendMessage,\n          appendMessage,\n          removeClusterLocally: dataHelpers.removeClusterLocally,\n        },\n        chatLocation: {\n          group: selectedGroup._id,\n          channel: selectedChannel._id,\n        },\n        failedIndex: content.reduce((result, message, index) => {\n          if (message.failed) result.push(index);\n          return result;\n        }, []),\n      };\n    }\n\n    // renders the individual messages in the cluster\n    content.forEach((message) => {\n      // some messages can be null if saved out of order, so check\n      if (message) {\n        messageStack.push(\n          <Message\n            key={message.timestamp}\n            text={message.text}\n            image={message.file}\n            pending={message._id ? false : true}\n            failed={message.failed} // indicates fails on messages\n            retryObject={isGenesis ? retryObject : null} // enables retry actions on genesis message if any child failed\n          />\n        );\n      }\n      if (isGenesis) isGenesis = false;\n    });\n\n    return messageStack;\n  }\n\n  chatData.forEach((cluster) => {\n    clusterStack.push(\n      <Sender\n        clusterId={cluster._id}\n        sender={cluster.sender}\n        timestamp={cluster.clusterTimestamp}\n        key={cluster.clusterTimestamp}\n        pending={cluster._id ? false : true}\n        mentions={cluster.mentions}\n        reply={cluster.reply}\n      >\n        {renderMessages(cluster)}\n      </Sender>\n    );\n  });\n  return clusterStack;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}