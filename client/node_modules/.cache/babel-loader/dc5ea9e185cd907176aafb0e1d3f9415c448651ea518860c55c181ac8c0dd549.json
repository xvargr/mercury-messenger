{"ast":null,"code":"import _toConsumableArray from\"/home/agreus/Documents/webdev/mercury-messenger/client/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";import _objectSpread from\"/home/agreus/Documents/webdev/mercury-messenger/client/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import{useContext,useEffect,useRef}from\"react\";import{DataContext}from\"../components/context/DataContext\";import{SocketContext}from\"../components/context/SocketContext\";export default function useSocket(){var _useContext=useContext(DataContext),groupData=_useContext.groupData,setGroupData=_useContext.setGroupData,statusForced=_useContext.statusForced,setStatusForced=_useContext.setStatusForced,peerHelpers=_useContext.peerHelpers;var _useContext2=useContext(SocketContext),socket=_useContext2.socket;var userStatus=peerHelpers.getStatus(localStorage.userId);var socketTimeout=12000;// 12 secs\nvar awayTimeout=180000;// 3 minutes\n// stale closure fix\nvar socketRef=useRef(socket);useEffect(function(){socketRef.current=socket;},[socket]);var statusForcedRef=useRef(statusForced);useEffect(function(){statusForcedRef.current=statusForced;},[statusForced]);// timers\nvar mouseMoveTimerRef=useRef(null);var awayTimerRef=useRef(null);// update the server on user status change\nfunction statusUpdater(){function emitStatus(params){var status=params.status;var validStatuses=[\"online\",\"away\",\"busy\",\"offline\"];var effectiveSocket;if(!validStatuses.includes(status))throw new Error(\"invalid status parameter\");if(socket)effectiveSocket=socket;else if(socketRef.current){effectiveSocket=socketRef.current;}else{// console.warn(\"socket not ready\");\nreturn null;}effectiveSocket.emit(\"statusChange\",{status:status});}function setAwayTimeout(){awayTimerRef.current=setTimeout(function(){if(!statusForcedRef.current)emitStatus({status:\"away\"});mouseMoveTimerRef.current=null;},awayTimeout);}// console.log(\"ref\", statusForcedRef.current, \"state\", statusForced); // always false\n// big headache, turns out hooks like this are not like context providers, every time they're called,\n// a new instance of this hook is created, so when the hook in userBadge updates it's forced state,\n// the hook instance in the main window is not affected, and vice versa. Even refs don't update,\n// because they are different instances, which is also why clearing timeouts doesn't work in the\n// forceStatusUpdate function\n// console.log(statusForcedRef.current);\n// console.log(userStatus);\n// if timer is not set, set it\nif(!(mouseMoveTimerRef!==null&&mouseMoveTimerRef!==void 0&&mouseMoveTimerRef.current)){if(!statusForcedRef.current&&userStatus===\"away\"){emitStatus({status:\"online\"});}mouseMoveTimerRef.current=Date.now();setAwayTimeout();}// throttler, if time passed since last scroll evt <150ms ignore and reset away timer\nelse if(Date.now()-mouseMoveTimerRef.current<150){mouseMoveTimerRef.current=Date.now();clearTimeout(awayTimerRef.current);setAwayTimeout();}}function forceStatusUpdate(status){if(status===\"online\")setStatusForced(false);else setStatusForced(true);socket.emit(\"statusChange\",{status:status,forced:status===\"online\"?false:true});statusUpdater();}function sendMessage(args){var message=args.message,target=args.target,failed=args.failed;var genesisCluster={target:target,data:message};var pendingCluster={sender:{username:localStorage.username,userImage:{thumbnailMedium:localStorage.userImageMedium}},channel:{},content:[genesisCluster.data],clusterTimestamp:message.timestamp};// push unsaved, non-failed cluster to message stack, failed messages property gets reset to null on retry\nsetGroupData(function(prevStack){var dataCopy=_objectSpread({},prevStack);var stackCopy=_toConsumableArray(dataCopy[target.group].chatData[target.channel]);if(!failed)stackCopy.push(pendingCluster);else{var clusterIndex=stackCopy.findIndex(function(cluster){return cluster.clusterTimestamp===message.timestamp;});stackCopy[clusterIndex].content[0].failed=null;}dataCopy[target.group].chatData[target.channel]=stackCopy;return dataCopy;});function genesisAcknowledged(res){setGroupData(function(prevStack){// setState expression is used to access the latest pending state before rerender\n// spread so that the values instead of the pointer is referenced by the new variable\n// else state will see no change since the pointer doesn't change even if the values did\n// make a copy of the whole chatData and the specific chat being modified\nvar dataCopy=_objectSpread({},prevStack);var stackCopy=_toConsumableArray(dataCopy[res.target.group].chatData[res.target.channel]);var clusterIndex=stackCopy.findIndex(function(message){return message.clusterTimestamp===res.data.clusterTimestamp;});var contentCopy=stackCopy[clusterIndex].content;contentCopy[0]=res.data.content[0];// copy and move previous content with acknowledged content added\nstackCopy[clusterIndex]=res.data;stackCopy[clusterIndex].content=contentCopy;dataCopy[res.target.group].chatData[res.target.channel]=stackCopy;return dataCopy;});}function genesisTimedOut(){setGroupData(function(prevStack){var dataCopy=_objectSpread({},prevStack);var stackCopy=_toConsumableArray(dataCopy[target.group].chatData[target.channel]);var clusterIndex=stackCopy.findIndex(function(message){return message.clusterTimestamp===pendingCluster.clusterTimestamp;});stackCopy[clusterIndex].content[0].failed={// was just setting {failed = res} here, that results in a circular reference that fails json.stringify in emit method\nmessage:_objectSpread({},message),target:_objectSpread({},target),status:true};dataCopy[target.group].chatData[target.channel]=stackCopy;return dataCopy;});}// console.log(JSON.stringify(genesisCluster)); // emit fails with arg as failed object as it is a circular reference, fix by spread or reassigning\nsocket.timeout(socketTimeout).emit(\"newCluster\",_objectSpread({},genesisCluster),function(err,res){// set failed property on message if timed out or error\nif(err)genesisTimedOut();else genesisAcknowledged(res);});}function appendMessage(args){var message=args.message,parent=args.parent,target=args.target,failed=args.failed;// create an object with necessary info to send to api\nvar appendObject={target:{cluster:{timestamp:parent.clusterTimestamp?parent.clusterTimestamp:null,id:parent._id?parent._id:null},group:target.group,channel:target.channel},content:_objectSpread({},message)};// find the index of the parent to be append locally,\nvar clusterIndex;if(appendObject.target.cluster.id){clusterIndex=groupData[target.group].chatData[target.channel].findIndex(function(cluster){return cluster._id===appendObject.target.cluster.id;});}else{clusterIndex=groupData[target.group].chatData[target.channel].findIndex(function(cluster){return cluster.clusterTimestamp===appendObject.target.cluster.timestamp;});}// find index of pending message\nvar pendingIndex;if(!failed){pendingIndex=groupData[target.group].chatData[target.channel][clusterIndex].content.length;}else{pendingIndex=groupData[target.group].chatData[target.channel][clusterIndex].content.findIndex(function(content){return content.timestamp===message.timestamp;});}appendObject.target.index=pendingIndex;// index of message in cluster for backend parity\n// update local data with temporary data, if is a retry, reset failed property\nsetGroupData(function(prevStack){var dataCopy=_objectSpread({},prevStack);if(!failed){var updatedCluster=dataCopy[target.group].chatData[target.channel][clusterIndex];updatedCluster.content.push(message);dataCopy[target.group].chatData[target.channel][clusterIndex]=updatedCluster;}else{dataCopy[target.group].chatData[target.channel][clusterIndex].content[pendingIndex].failed=null;}return dataCopy;});function appendAcknowledged(res){setGroupData(function(prevStack){var dataCopy=_objectSpread({},prevStack);var stackCopy=_toConsumableArray(prevStack[res.target.group].chatData[res.target.channel]);var clusterIndex=stackCopy.findIndex(function(cluster){return cluster.id===res.target.cluster.id;});var thisCluster=_objectSpread({},dataCopy[res.target.group].chatData[res.target.channel][clusterIndex]);// find pending message\nvar messageIndex=stackCopy[clusterIndex].content.findIndex(function(message){return message.timestamp===(res.err?res.err:res.data.timestamp);});// index always 0 because ternary and operator precedence, use parentheses to eval right side first\nthisCluster.content[messageIndex]=res.data;if(res.data.mentions.length>0){res.data.mentions.forEach(function(newMention){var isNotMentioned=!thisCluster.mentions.some(function(existingMention){return existingMention._id===newMention._id;});if(isNotMentioned){thisCluster.mentions.push(newMention);}});}dataCopy[res.target.group].chatData[res.target.channel][clusterIndex]=thisCluster;return dataCopy;});}function appendTimedOut(){setGroupData(function(prevStack){var dataCopy=_objectSpread({},prevStack);var stackCopy=_toConsumableArray(prevStack[target.group].chatData[target.channel]);var clusterIndex=stackCopy.findIndex(function(cluster){return cluster.clusterTimestamp===appendObject.target.cluster.timestamp;});dataCopy[target.group].chatData[target.channel][clusterIndex].content[appendObject.target.index].failed={message:_objectSpread({},message),parent:_objectSpread({},parent),target:_objectSpread({},target),status:true};return dataCopy;});}socket.timeout(socketTimeout).emit(\"appendCluster\",appendObject,function(err,res){if(err||res.failed)appendTimedOut();// handle err if append fails on backend with res.failed in addition to timeout\nelse appendAcknowledged(res);});}function fetchMore(fetchParams){function patchChat(params){var partialChat=params.partialChat,target=params.target,_params$depleted=params.depleted,depleted=_params$depleted===void 0?false:_params$depleted;setGroupData(function(prevData){var dataCopy=_objectSpread({},prevData);var groupCopy=_objectSpread({},dataCopy[target.group]);var stackCopy=_toConsumableArray(groupCopy.chatData[target.channel]);groupCopy.chatData[target.channel]=[].concat(_toConsumableArray(partialChat),_toConsumableArray(stackCopy));if(depleted){groupCopy.chatDepleted[target.channel]=true;}dataCopy[target.group]=groupCopy;return dataCopy;});}function fetchReceived(res){patchChat({partialChat:res.data,target:res.target,depleted:res.depleted});}return new Promise(function(resolve,reject){resolve(socket.timeout(socketTimeout).emit(\"fetchMore\",fetchParams,function(err,res){if(err||res.failed)return{err:\"timed out\"};else fetchReceived(res);}));});}return{sendMessage:sendMessage,appendMessage:appendMessage,fetchMore:fetchMore,statusUpdater:statusUpdater,forceStatusUpdate:forceStatusUpdate};}","map":{"version":3,"names":["useContext","useEffect","useRef","DataContext","SocketContext","useSocket","groupData","setGroupData","statusForced","setStatusForced","peerHelpers","socket","userStatus","getStatus","localStorage","userId","socketTimeout","awayTimeout","socketRef","current","statusForcedRef","mouseMoveTimerRef","awayTimerRef","statusUpdater","emitStatus","params","status","validStatuses","effectiveSocket","includes","Error","emit","setAwayTimeout","setTimeout","Date","now","clearTimeout","forceStatusUpdate","forced","sendMessage","args","message","target","failed","genesisCluster","data","pendingCluster","sender","username","userImage","thumbnailMedium","userImageMedium","channel","content","clusterTimestamp","timestamp","prevStack","dataCopy","stackCopy","group","chatData","push","clusterIndex","findIndex","cluster","genesisAcknowledged","res","contentCopy","genesisTimedOut","timeout","err","appendMessage","parent","appendObject","id","_id","pendingIndex","length","index","updatedCluster","appendAcknowledged","thisCluster","messageIndex","mentions","forEach","newMention","isNotMentioned","some","existingMention","appendTimedOut","fetchMore","fetchParams","patchChat","partialChat","depleted","prevData","groupCopy","chatDepleted","fetchReceived","Promise","resolve","reject"],"sources":["/home/agreus/Documents/webdev/mercury-messenger/client/src/utils/socket.js"],"sourcesContent":["import { useContext, useEffect, useRef } from \"react\";\n\nimport { DataContext } from \"../components/context/DataContext\";\nimport { SocketContext } from \"../components/context/SocketContext\";\n\nexport default function useSocket() {\n  const {\n    groupData,\n    setGroupData,\n    statusForced,\n    setStatusForced,\n    peerHelpers,\n  } = useContext(DataContext);\n  const { socket } = useContext(SocketContext);\n\n  const userStatus = peerHelpers.getStatus(localStorage.userId);\n\n  const socketTimeout = 12000; // 12 secs\n  const awayTimeout = 180000; // 3 minutes\n\n  // stale closure fix\n  const socketRef = useRef(socket);\n  useEffect(() => {\n    socketRef.current = socket;\n  }, [socket]);\n  const statusForcedRef = useRef(statusForced);\n  useEffect(() => {\n    statusForcedRef.current = statusForced;\n  }, [statusForced]);\n\n  // timers\n  const mouseMoveTimerRef = useRef(null);\n  const awayTimerRef = useRef(null);\n\n  // update the server on user status change\n  function statusUpdater() {\n    function emitStatus(params) {\n      const { status } = params;\n      const validStatuses = [\"online\", \"away\", \"busy\", \"offline\"];\n      let effectiveSocket;\n\n      if (!validStatuses.includes(status))\n        throw new Error(\"invalid status parameter\");\n\n      if (socket) effectiveSocket = socket;\n      else if (socketRef.current) {\n        effectiveSocket = socketRef.current;\n      } else {\n        // console.warn(\"socket not ready\");\n        return null;\n      }\n\n      effectiveSocket.emit(\"statusChange\", { status });\n    }\n\n    function setAwayTimeout() {\n      awayTimerRef.current = setTimeout(() => {\n        if (!statusForcedRef.current) emitStatus({ status: \"away\" });\n        mouseMoveTimerRef.current = null;\n      }, awayTimeout);\n    }\n\n    // console.log(\"ref\", statusForcedRef.current, \"state\", statusForced); // always false\n    // big headache, turns out hooks like this are not like context providers, every time they're called,\n    // a new instance of this hook is created, so when the hook in userBadge updates it's forced state,\n    // the hook instance in the main window is not affected, and vice versa. Even refs don't update,\n    // because they are different instances, which is also why clearing timeouts doesn't work in the\n    // forceStatusUpdate function\n\n    // console.log(statusForcedRef.current);\n    // console.log(userStatus);\n\n    // if timer is not set, set it\n    if (!mouseMoveTimerRef?.current) {\n      if (!statusForcedRef.current && userStatus === \"away\") {\n        emitStatus({ status: \"online\" });\n      }\n      mouseMoveTimerRef.current = Date.now();\n      setAwayTimeout();\n    }\n\n    // throttler, if time passed since last scroll evt <150ms ignore and reset away timer\n    else if (Date.now() - mouseMoveTimerRef.current < 150) {\n      mouseMoveTimerRef.current = Date.now();\n      clearTimeout(awayTimerRef.current);\n      setAwayTimeout();\n    }\n  }\n\n  function forceStatusUpdate(status) {\n    if (status === \"online\") setStatusForced(false);\n    else setStatusForced(true);\n\n    socket.emit(\"statusChange\", {\n      status,\n      forced: status === \"online\" ? false : true,\n    });\n    statusUpdater();\n  }\n\n  function sendMessage(args) {\n    const { message, target, failed } = args;\n    const genesisCluster = { target, data: message };\n    const pendingCluster = {\n      sender: {\n        username: localStorage.username,\n        userImage: {\n          thumbnailMedium: localStorage.userImageMedium,\n        },\n      },\n      channel: {},\n      content: [genesisCluster.data],\n      clusterTimestamp: message.timestamp,\n    };\n\n    // push unsaved, non-failed cluster to message stack, failed messages property gets reset to null on retry\n    setGroupData((prevStack) => {\n      const dataCopy = { ...prevStack };\n      const stackCopy = [...dataCopy[target.group].chatData[target.channel]];\n\n      if (!failed) stackCopy.push(pendingCluster);\n      else {\n        const clusterIndex = stackCopy.findIndex(\n          (cluster) => cluster.clusterTimestamp === message.timestamp\n        );\n\n        stackCopy[clusterIndex].content[0].failed = null;\n      }\n\n      dataCopy[target.group].chatData[target.channel] = stackCopy;\n\n      return dataCopy;\n    });\n\n    function genesisAcknowledged(res) {\n      setGroupData((prevStack) => {\n        // setState expression is used to access the latest pending state before rerender\n        // spread so that the values instead of the pointer is referenced by the new variable\n        // else state will see no change since the pointer doesn't change even if the values did\n        // make a copy of the whole chatData and the specific chat being modified\n        const dataCopy = { ...prevStack };\n        const stackCopy = [\n          ...dataCopy[res.target.group].chatData[res.target.channel],\n        ];\n\n        const clusterIndex = stackCopy.findIndex(\n          (message) => message.clusterTimestamp === res.data.clusterTimestamp\n        );\n\n        const contentCopy = stackCopy[clusterIndex].content;\n\n        contentCopy[0] = res.data.content[0];\n\n        // copy and move previous content with acknowledged content added\n        stackCopy[clusterIndex] = res.data;\n        stackCopy[clusterIndex].content = contentCopy;\n\n        dataCopy[res.target.group].chatData[res.target.channel] = stackCopy;\n\n        return dataCopy;\n      });\n    }\n\n    function genesisTimedOut() {\n      setGroupData((prevStack) => {\n        const dataCopy = { ...prevStack };\n        const stackCopy = [...dataCopy[target.group].chatData[target.channel]];\n\n        const clusterIndex = stackCopy.findIndex(\n          (message) =>\n            message.clusterTimestamp === pendingCluster.clusterTimestamp\n        );\n\n        stackCopy[clusterIndex].content[0].failed = {\n          // was just setting {failed = res} here, that results in a circular reference that fails json.stringify in emit method\n          message: { ...message },\n          target: { ...target },\n          status: true,\n        };\n\n        dataCopy[target.group].chatData[target.channel] = stackCopy;\n\n        return dataCopy;\n      });\n    }\n\n    // console.log(JSON.stringify(genesisCluster)); // emit fails with arg as failed object as it is a circular reference, fix by spread or reassigning\n\n    socket\n      .timeout(socketTimeout)\n      .emit(\"newCluster\", { ...genesisCluster }, (err, res) => {\n        // set failed property on message if timed out or error\n        if (err) genesisTimedOut();\n        else genesisAcknowledged(res);\n      });\n  }\n\n  function appendMessage(args) {\n    const { message, parent, target, failed } = args;\n\n    // create an object with necessary info to send to api\n    const appendObject = {\n      target: {\n        cluster: {\n          timestamp: parent.clusterTimestamp ? parent.clusterTimestamp : null,\n          id: parent._id ? parent._id : null,\n        },\n        group: target.group,\n        channel: target.channel,\n      },\n      content: { ...message },\n    };\n\n    // find the index of the parent to be append locally,\n    let clusterIndex;\n    if (appendObject.target.cluster.id) {\n      clusterIndex = groupData[target.group].chatData[target.channel].findIndex(\n        (cluster) => cluster._id === appendObject.target.cluster.id\n      );\n    } else {\n      clusterIndex = groupData[target.group].chatData[target.channel].findIndex(\n        (cluster) =>\n          cluster.clusterTimestamp === appendObject.target.cluster.timestamp\n      );\n    }\n\n    // find index of pending message\n    let pendingIndex;\n    if (!failed) {\n      pendingIndex =\n        groupData[target.group].chatData[target.channel][clusterIndex].content\n          .length;\n    } else {\n      pendingIndex = groupData[target.group].chatData[target.channel][\n        clusterIndex\n      ].content.findIndex((content) => content.timestamp === message.timestamp);\n    }\n\n    appendObject.target.index = pendingIndex; // index of message in cluster for backend parity\n\n    // update local data with temporary data, if is a retry, reset failed property\n    setGroupData((prevStack) => {\n      const dataCopy = { ...prevStack };\n\n      if (!failed) {\n        const updatedCluster =\n          dataCopy[target.group].chatData[target.channel][clusterIndex];\n        updatedCluster.content.push(message);\n\n        dataCopy[target.group].chatData[target.channel][clusterIndex] =\n          updatedCluster;\n      } else {\n        dataCopy[target.group].chatData[target.channel][clusterIndex].content[\n          pendingIndex\n        ].failed = null;\n      }\n\n      return dataCopy;\n    });\n\n    function appendAcknowledged(res) {\n      setGroupData((prevStack) => {\n        const dataCopy = { ...prevStack };\n        const stackCopy = [\n          ...prevStack[res.target.group].chatData[res.target.channel],\n        ];\n\n        const clusterIndex = stackCopy.findIndex(\n          (cluster) => cluster.id === res.target.cluster.id\n        );\n\n        const thisCluster = {\n          ...dataCopy[res.target.group].chatData[res.target.channel][\n            clusterIndex\n          ],\n        };\n\n        // find pending message\n        const messageIndex = stackCopy[clusterIndex].content.findIndex(\n          (message) =>\n            message.timestamp === (res.err ? res.err : res.data.timestamp)\n        ); // index always 0 because ternary and operator precedence, use parentheses to eval right side first\n\n        thisCluster.content[messageIndex] = res.data;\n\n        if (res.data.mentions.length > 0) {\n          res.data.mentions.forEach((newMention) => {\n            const isNotMentioned = !thisCluster.mentions.some(\n              (existingMention) => existingMention._id === newMention._id\n            );\n\n            if (isNotMentioned) {\n              thisCluster.mentions.push(newMention);\n            }\n          });\n        }\n\n        dataCopy[res.target.group].chatData[res.target.channel][clusterIndex] =\n          thisCluster;\n\n        return dataCopy;\n      });\n    }\n\n    function appendTimedOut() {\n      setGroupData((prevStack) => {\n        const dataCopy = { ...prevStack };\n        const stackCopy = [...prevStack[target.group].chatData[target.channel]];\n\n        const clusterIndex = stackCopy.findIndex(\n          (cluster) =>\n            cluster.clusterTimestamp === appendObject.target.cluster.timestamp\n        );\n\n        dataCopy[target.group].chatData[target.channel][clusterIndex].content[\n          appendObject.target.index\n        ].failed = {\n          message: { ...message },\n          parent: { ...parent },\n          target: { ...target },\n          status: true,\n        };\n\n        return dataCopy;\n      });\n    }\n\n    socket\n      .timeout(socketTimeout)\n      .emit(\"appendCluster\", appendObject, (err, res) => {\n        if (err || res.failed)\n          appendTimedOut(); // handle err if append fails on backend with res.failed in addition to timeout\n        else appendAcknowledged(res);\n      });\n  }\n\n  function fetchMore(fetchParams) {\n    function patchChat(params) {\n      const { partialChat, target, depleted = false } = params;\n\n      setGroupData((prevData) => {\n        const dataCopy = { ...prevData };\n        const groupCopy = { ...dataCopy[target.group] };\n        const stackCopy = [...groupCopy.chatData[target.channel]];\n\n        groupCopy.chatData[target.channel] = [...partialChat, ...stackCopy];\n        if (depleted) {\n          groupCopy.chatDepleted[target.channel] = true;\n        }\n\n        dataCopy[target.group] = groupCopy;\n\n        return dataCopy;\n      });\n    }\n\n    function fetchReceived(res) {\n      patchChat({\n        partialChat: res.data,\n        target: res.target,\n        depleted: res.depleted,\n      });\n    }\n\n    return new Promise((resolve, reject) => {\n      resolve(\n        socket\n          .timeout(socketTimeout)\n          .emit(\"fetchMore\", fetchParams, (err, res) => {\n            if (err || res.failed) return { err: \"timed out\" };\n            else fetchReceived(res);\n          })\n      );\n    });\n  }\n\n  return {\n    sendMessage,\n    appendMessage,\n    fetchMore,\n    statusUpdater,\n    forceStatusUpdate,\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}