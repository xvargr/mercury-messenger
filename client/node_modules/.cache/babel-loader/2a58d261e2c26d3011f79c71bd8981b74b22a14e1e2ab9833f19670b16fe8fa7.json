{"ast":null,"code":"var _jsxFileName = \"/home/agreus/Documents/webdev/mercury-messenger/client/src/components/context/DataContext.js\",\n  _s = $RefreshSig$();\nimport { useState, createContext, useEffect, useRef } from \"react\";\n\n// utility hooks\nimport useLocalFallback from \"../../utils/localFallback\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const DataContext = /*#__PURE__*/createContext(); // use this to access the values here\n\n// use this to wrap around components that needs to access the values here\nexport function DataStateProvider(props) {\n  _s();\n  const [groupData, setGroupData] = useState(null);\n  const [peerData, setPeerData] = useState({});\n  const [dataMounted, setDataMounted] = useState(false);\n  const [chatMounted, setChatMounted] = useState(false);\n  const [selectedGroup, setSelectedGroup] = useState(null);\n  const [selectedChannel, setSelectedChannel] = useState(null);\n  const [selectedChatIsDepleted, setSelectedChatIsDepleted] = useState(true);\n  const [stateRestored, setStateRestored] = useState(false);\n  const [dataReady, setDataReady] = useState(false);\n  const [isLoggedIn, setIsLoggedIn] = useState(false);\n  const [windowIsFocused, setWindowIsFocused] = useState(true);\n  const [statusForced, setStatusForced] = useState(false);\n  const [unreadState, setUnreadState] = useState({});\n  const [socketError, setSocketError] = useState(null);\n  const {\n    updateStored\n  } = useLocalFallback();\n\n  // this ref is used to prevent stale closure in the helper functions below\n  const groupDataRef = useRef(groupData);\n  useEffect(() => {\n    groupDataRef.current = groupData;\n  }, [groupData]);\n\n  // backup selected context id on change\n  // clear unread on enter chat\n  useEffect(() => {\n    if (selectedGroup) updateStored.group(selectedGroup);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [selectedGroup]);\n  useEffect(() => {\n    if (selectedChannel) {\n      setUnread({\n        channelId: selectedChannel._id,\n        clear: true\n      });\n      updateStored.channel(selectedChannel);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [selectedChannel]);\n\n  // chatDepleted status updater\n  useEffect(() => {\n    if (!selectedGroup || !selectedChannel || !dataReady) setSelectedChatIsDepleted(false);else if (groupData[selectedGroup] !== selectedGroup) {\n      var _groupData$selectedGr, _groupData$selectedGr2;\n      let isDepleted; // ! unstable\n      if (((_groupData$selectedGr = groupData[selectedGroup._id].chatData[selectedChannel._id]) === null || _groupData$selectedGr === void 0 ? void 0 : _groupData$selectedGr.length) < 20 || (_groupData$selectedGr2 = groupData[selectedGroup._id].chatDepleted) !== null && _groupData$selectedGr2 !== void 0 && _groupData$selectedGr2[selectedChannel._id]) {\n        isDepleted = true;\n      } else {\n        isDepleted = false;\n      }\n      setSelectedChatIsDepleted(isDepleted);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [selectedChannel, groupData, dataReady]);\n\n  // todo change selected context if main grpData changes\n\n  // window is focused detection used for notification sounds\n  useEffect(() => {\n    window.addEventListener(\"focus\", () => setWindowIsFocused(true));\n    window.addEventListener(\"blur\", () => setWindowIsFocused(false));\n    return () => {\n      window.addEventListener(\"focus\", () => setWindowIsFocused(true));\n      window.addEventListener(\"blur\", () => setWindowIsFocused(false));\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  // set if everything is ready to show\n  useEffect(() => {\n    if (dataMounted && chatMounted && stateRestored) setDataReady(true);else setDataReady(false);\n  }, [dataMounted, chatMounted, stateRestored]);\n  function getUnread(params) {\n    const {\n      groupId,\n      channelId\n    } = params;\n    let unreadCount;\n    if (!groupId && !channelId) {\n      console.warn(\"invalid params\");\n      return null;\n    }\n    if (channelId) {\n      unreadCount = unreadState[channelId];\n    } else if (groupId) {\n      const channels = groupData[groupId].channels.text;\n      unreadCount = channels.reduce((accumulator, channel) => {\n        var _unreadState$channel$;\n        return accumulator + ((_unreadState$channel$ = unreadState[channel._id]) !== null && _unreadState$channel$ !== void 0 ? _unreadState$channel$ : 0);\n      }, 0);\n    }\n    return unreadCount > 0 ? unreadCount : 0;\n  }\n  function setUnread(params) {\n    const {\n      channelId,\n      add,\n      clear\n    } = params;\n    setUnreadState(prevState => {\n      const stateCopy = {\n        ...prevState\n      };\n      if (add) {\n        stateCopy[channelId] = (stateCopy === null || stateCopy === void 0 ? void 0 : stateCopy[channelId]) > 0 ? stateCopy[channelId] + 1 : 1;\n      } else if (clear) delete stateCopy[channelId];\n      return stateCopy;\n    });\n  }\n  function isAdmin() {\n    return selectedGroup === null || selectedGroup === void 0 ? void 0 : selectedGroup.administrators.some(admin => admin._id === localStorage.userId);\n  }\n  function clearSelected() {\n    setSelectedChannel(null);\n    setSelectedGroup(null);\n  }\n  function mountChat(chatObject, depletedObject) {\n    setGroupData(prevData => {\n      const dataCopy = {\n        ...prevData\n      };\n      for (const groupId in chatObject) {\n        dataCopy[groupId].chatData = {\n          ...chatObject[groupId]\n        };\n      }\n      for (const groupId in depletedObject) {\n        dataCopy[groupId].chatDepleted = {\n          ...depletedObject[groupId]\n        };\n      }\n      return dataCopy;\n    });\n    setChatMounted(true);\n  }\n  function getChannelIndex(parentId, channelId) {\n    var _groupDataRef$current;\n    const dataArray = (_groupDataRef$current = groupDataRef.current) !== null && _groupDataRef$current !== void 0 ? _groupDataRef$current : groupData;\n    const result = dataArray[parentId].channels.text.findIndex(channel => channel._id === channelId);\n    return result;\n  }\n  function addNewChat(groupIdString, channelIdString, chatData) {\n    setGroupData(prevData => {\n      const dataCopy = {\n        ...prevData\n      };\n      dataCopy[groupIdString].chatData[channelIdString] = chatData ? chatData[groupIdString][channelIdString] : []; // assumes new empty chat if no data was passed\n\n      return dataCopy;\n    });\n  }\n  function addNewGroup(groupObject, chatData, chatDepleted) {\n    setGroupData(prevData => {\n      const dataCopy = {\n        ...prevData\n      };\n      dataCopy[groupObject._id] = groupObject;\n      dataCopy[groupObject._id].chatData = {};\n      dataCopy[groupObject._id].chatDepleted = {\n        ...chatDepleted\n      };\n      return dataCopy;\n    });\n    groupObject.channels.text.forEach(channel => addNewChat(groupObject._id, channel._id, chatData));\n  }\n  function removeGroup(groupIdString) {\n    setGroupData(prevData => {\n      const dataCopy = {\n        ...prevData\n      };\n      delete dataCopy[groupIdString];\n      return dataCopy;\n    });\n  }\n  function patchGroup(groupObject) {\n    setGroupData(prevData => {\n      const dataCopy = {\n        ...prevData\n      };\n      const chatCopy = {\n        ...dataCopy[groupObject._id].chatData\n      };\n      const depletedCopy = {\n        ...dataCopy[groupObject._id].chatDepleted\n      };\n      dataCopy[groupObject._id] = groupObject;\n      dataCopy[groupObject._id].chatData = chatCopy;\n      dataCopy[groupObject._id].chatDepleted = depletedCopy;\n      return dataCopy;\n    });\n  }\n  function removeClusterLocally(deletionParams) {\n    const {\n      target,\n      deleteCluster,\n      indexes\n    } = deletionParams;\n    if (!deleteCluster && !indexes) {\n      // throw new Error(\"invalid parameters\");\n      console.error(\"invalid parameters\");\n      return null;\n    }\n    if (deleteCluster) {\n      setGroupData(prevData => {\n        const dataCopy = {\n          ...prevData\n        };\n        const stackCopy = [...dataCopy[target.group].chatData[target.channel]];\n        const filteredStack = stackCopy.filter(cluster => cluster.clusterTimestamp !== target.clusterTimestamp);\n        dataCopy[target.group].chatData[target.channel] = filteredStack;\n        return dataCopy;\n      });\n    } else if (indexes) {\n      setGroupData(prevData => {\n        const dataCopy = {\n          ...prevData\n        };\n        const stackCopy = [...dataCopy[target.group].chatData[target.channel]];\n        let indexModifier = 0;\n        const clusterIndex = stackCopy.findIndex(cluster => cluster.clusterTimestamp === target.clusterTimestamp);\n        if (clusterIndex < 0) {\n          // throw new Error(\"cluster not found\");\n          console.error(\"cluster not found\");\n          return null;\n        }\n        indexes.forEach(index => {\n          stackCopy[clusterIndex].content.splice(index - indexModifier, 1);\n          indexModifier++;\n        });\n        dataCopy[target.group].chatData[target.channel] = stackCopy;\n        return dataCopy;\n      });\n    }\n  }\n  function getStatus(idString) {\n    var _peerData$idString;\n    return ((_peerData$idString = peerData[idString]) === null || _peerData$idString === void 0 ? void 0 : _peerData$idString.status) || \"offline\";\n  }\n  function mergePeers(partialData) {\n    setPeerData(prevData => {\n      return {\n        ...prevData,\n        ...partialData\n      };\n    });\n  }\n  function changeStatus(params) {\n    const {\n      target,\n      change\n    } = params;\n    const validStatuses = [\"online\", \"away\", \"busy\", \"offline\"];\n    if (!validStatuses.includes(change)) {\n      // throw new Error(\"invalid status parameter\");\n      console.error(\"invalid status parameters\");\n      return null;\n    }\n    if (!target) {\n      // throw new Error(\"no id passed\");\n      console.error(\"id required\");\n      return null;\n    }\n    setPeerData(prevData => {\n      const dataCopy = {\n        ...prevData\n      };\n      if (!dataCopy[target]) dataCopy[target] = {\n        status: \"offline\"\n      };\n      dataCopy[target].status = change;\n      return dataCopy;\n    });\n  }\n  function getLastInfo(groupId, channelId) {\n    const chatStack = groupData[groupId].chatData[channelId];\n    const elapsed = chatStack.length > 0 ? Date.now() - chatStack[chatStack.length - 1].clusterTimestamp : 0;\n    const lastSender = chatStack.length > 0 ? chatStack[chatStack.length - 1].sender.username : null;\n    const lastCluster = chatStack.length > 0 ? chatStack[chatStack.length - 1] : null;\n    return {\n      elapsed,\n      lastCluster,\n      lastSender\n    };\n  }\n  const dataState = {\n    groupData,\n    setGroupData,\n    dataMounted,\n    setDataMounted,\n    chatMounted,\n    setChatMounted,\n    isLoggedIn,\n    setIsLoggedIn,\n    peerData,\n    setPeerData,\n    dataReady,\n    stateRestored,\n    setStateRestored,\n    mountChat,\n    selectedGroup,\n    setSelectedGroup,\n    selectedChannel,\n    setSelectedChannel,\n    windowIsFocused,\n    setWindowIsFocused,\n    clearSelected,\n    isAdmin,\n    selectedChatIsDepleted,\n    statusForced,\n    setStatusForced,\n    socketError,\n    setSocketError,\n    dataHelpers: {\n      getChannelIndex,\n      addNewGroup,\n      removeGroup,\n      patchGroup,\n      getLastInfo,\n      mergePeers,\n      removeClusterLocally,\n      getUnread,\n      setUnread\n    },\n    peerHelpers: {\n      getStatus,\n      changeStatus\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(DataContext.Provider, {\n    value: dataState,\n    children: props.children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 368,\n    columnNumber: 5\n  }, this);\n}\n_s(DataStateProvider, \"EJ1jx/gL5YNp9619dSv8qKlxUv0=\", false, function () {\n  return [useLocalFallback];\n});\n_c = DataStateProvider;\nvar _c;\n$RefreshReg$(_c, \"DataStateProvider\");","map":{"version":3,"names":["useState","createContext","useEffect","useRef","useLocalFallback","DataContext","DataStateProvider","props","groupData","setGroupData","peerData","setPeerData","dataMounted","setDataMounted","chatMounted","setChatMounted","selectedGroup","setSelectedGroup","selectedChannel","setSelectedChannel","selectedChatIsDepleted","setSelectedChatIsDepleted","stateRestored","setStateRestored","dataReady","setDataReady","isLoggedIn","setIsLoggedIn","windowIsFocused","setWindowIsFocused","statusForced","setStatusForced","unreadState","setUnreadState","socketError","setSocketError","updateStored","groupDataRef","current","group","setUnread","channelId","_id","clear","channel","isDepleted","chatData","length","chatDepleted","window","addEventListener","getUnread","params","groupId","unreadCount","console","warn","channels","text","reduce","accumulator","add","prevState","stateCopy","isAdmin","administrators","some","admin","localStorage","userId","clearSelected","mountChat","chatObject","depletedObject","prevData","dataCopy","getChannelIndex","parentId","dataArray","result","findIndex","addNewChat","groupIdString","channelIdString","addNewGroup","groupObject","forEach","removeGroup","patchGroup","chatCopy","depletedCopy","removeClusterLocally","deletionParams","target","deleteCluster","indexes","error","stackCopy","filteredStack","filter","cluster","clusterTimestamp","indexModifier","clusterIndex","index","content","splice","getStatus","idString","status","mergePeers","partialData","changeStatus","change","validStatuses","includes","getLastInfo","chatStack","elapsed","Date","now","lastSender","sender","username","lastCluster","dataState","dataHelpers","peerHelpers","children"],"sources":["/home/agreus/Documents/webdev/mercury-messenger/client/src/components/context/DataContext.js"],"sourcesContent":["import { useState, createContext, useEffect, useRef } from \"react\";\n\n// utility hooks\nimport useLocalFallback from \"../../utils/localFallback\";\n\nexport const DataContext = createContext(); // use this to access the values here\n\n// use this to wrap around components that needs to access the values here\nexport function DataStateProvider(props) {\n  const [groupData, setGroupData] = useState(null);\n  const [peerData, setPeerData] = useState({});\n\n  const [dataMounted, setDataMounted] = useState(false);\n  const [chatMounted, setChatMounted] = useState(false);\n\n  const [selectedGroup, setSelectedGroup] = useState(null);\n  const [selectedChannel, setSelectedChannel] = useState(null);\n\n  const [selectedChatIsDepleted, setSelectedChatIsDepleted] = useState(true);\n  const [stateRestored, setStateRestored] = useState(false);\n  const [dataReady, setDataReady] = useState(false);\n\n  const [isLoggedIn, setIsLoggedIn] = useState(false);\n  const [windowIsFocused, setWindowIsFocused] = useState(true);\n  const [statusForced, setStatusForced] = useState(false);\n\n  const [unreadState, setUnreadState] = useState({});\n\n  const [socketError, setSocketError] = useState(null);\n\n  const { updateStored } = useLocalFallback();\n\n  // this ref is used to prevent stale closure in the helper functions below\n  const groupDataRef = useRef(groupData);\n  useEffect(() => {\n    groupDataRef.current = groupData;\n  }, [groupData]);\n\n  // backup selected context id on change\n  // clear unread on enter chat\n  useEffect(() => {\n    if (selectedGroup) updateStored.group(selectedGroup);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [selectedGroup]);\n  useEffect(() => {\n    if (selectedChannel) {\n      setUnread({ channelId: selectedChannel._id, clear: true });\n      updateStored.channel(selectedChannel);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [selectedChannel]);\n\n  // chatDepleted status updater\n  useEffect(() => {\n    if (!selectedGroup || !selectedChannel || !dataReady)\n      setSelectedChatIsDepleted(false);\n    else if (groupData[selectedGroup] !== selectedGroup) {\n      let isDepleted; // ! unstable\n      if (\n        groupData[selectedGroup._id].chatData[selectedChannel._id]?.length <\n          20 ||\n        groupData[selectedGroup._id].chatDepleted?.[selectedChannel._id]\n      ) {\n        isDepleted = true;\n      } else {\n        isDepleted = false;\n      }\n\n      setSelectedChatIsDepleted(isDepleted);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [selectedChannel, groupData, dataReady]);\n\n  // todo change selected context if main grpData changes\n\n  // window is focused detection used for notification sounds\n  useEffect(() => {\n    window.addEventListener(\"focus\", () => setWindowIsFocused(true));\n    window.addEventListener(\"blur\", () => setWindowIsFocused(false));\n    return () => {\n      window.addEventListener(\"focus\", () => setWindowIsFocused(true));\n      window.addEventListener(\"blur\", () => setWindowIsFocused(false));\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  // set if everything is ready to show\n  useEffect(() => {\n    if (dataMounted && chatMounted && stateRestored) setDataReady(true);\n    else setDataReady(false);\n  }, [dataMounted, chatMounted, stateRestored]);\n\n  function getUnread(params) {\n    const { groupId, channelId } = params;\n    let unreadCount;\n\n    if (!groupId && !channelId) {\n      console.warn(\"invalid params\");\n      return null;\n    }\n\n    if (channelId) {\n      unreadCount = unreadState[channelId];\n    } else if (groupId) {\n      const channels = groupData[groupId].channels.text;\n      unreadCount = channels.reduce((accumulator, channel) => {\n        return accumulator + (unreadState[channel._id] ?? 0);\n      }, 0);\n    }\n\n    return unreadCount > 0 ? unreadCount : 0;\n  }\n\n  function setUnread(params) {\n    const { channelId, add, clear } = params;\n\n    setUnreadState((prevState) => {\n      const stateCopy = { ...prevState };\n\n      if (add) {\n        stateCopy[channelId] =\n          stateCopy?.[channelId] > 0 ? stateCopy[channelId] + 1 : 1;\n      } else if (clear) delete stateCopy[channelId];\n\n      return stateCopy;\n    });\n  }\n\n  function isAdmin() {\n    return selectedGroup?.administrators.some(\n      (admin) => admin._id === localStorage.userId\n    );\n  }\n\n  function clearSelected() {\n    setSelectedChannel(null);\n    setSelectedGroup(null);\n  }\n\n  function mountChat(chatObject, depletedObject) {\n    setGroupData((prevData) => {\n      const dataCopy = { ...prevData };\n\n      for (const groupId in chatObject) {\n        dataCopy[groupId].chatData = { ...chatObject[groupId] };\n      }\n\n      for (const groupId in depletedObject) {\n        dataCopy[groupId].chatDepleted = { ...depletedObject[groupId] };\n      }\n\n      return dataCopy;\n    });\n\n    setChatMounted(true);\n  }\n\n  function getChannelIndex(parentId, channelId) {\n    const dataArray = groupDataRef.current ?? groupData;\n    const result = dataArray[parentId].channels.text.findIndex(\n      (channel) => channel._id === channelId\n    );\n    return result;\n  }\n\n  function addNewChat(groupIdString, channelIdString, chatData) {\n    setGroupData((prevData) => {\n      const dataCopy = { ...prevData };\n\n      dataCopy[groupIdString].chatData[channelIdString] = chatData\n        ? chatData[groupIdString][channelIdString]\n        : []; // assumes new empty chat if no data was passed\n\n      return dataCopy;\n    });\n  }\n\n  function addNewGroup(groupObject, chatData, chatDepleted) {\n    setGroupData((prevData) => {\n      const dataCopy = { ...prevData };\n\n      dataCopy[groupObject._id] = groupObject;\n      dataCopy[groupObject._id].chatData = {};\n      dataCopy[groupObject._id].chatDepleted = {\n        ...chatDepleted,\n      };\n\n      return dataCopy;\n    });\n\n    groupObject.channels.text.forEach((channel) =>\n      addNewChat(groupObject._id, channel._id, chatData)\n    );\n  }\n\n  function removeGroup(groupIdString) {\n    setGroupData((prevData) => {\n      const dataCopy = { ...prevData };\n      delete dataCopy[groupIdString];\n      return dataCopy;\n    });\n  }\n\n  function patchGroup(groupObject) {\n    setGroupData((prevData) => {\n      const dataCopy = { ...prevData };\n      const chatCopy = { ...dataCopy[groupObject._id].chatData };\n      const depletedCopy = { ...dataCopy[groupObject._id].chatDepleted };\n\n      dataCopy[groupObject._id] = groupObject;\n      dataCopy[groupObject._id].chatData = chatCopy;\n      dataCopy[groupObject._id].chatDepleted = depletedCopy;\n\n      return dataCopy;\n    });\n  }\n\n  function removeClusterLocally(deletionParams) {\n    const { target, deleteCluster, indexes } = deletionParams;\n\n    if (!deleteCluster && !indexes) {\n      // throw new Error(\"invalid parameters\");\n      console.error(\"invalid parameters\");\n      return null;\n    }\n\n    if (deleteCluster) {\n      setGroupData((prevData) => {\n        const dataCopy = { ...prevData };\n        const stackCopy = [...dataCopy[target.group].chatData[target.channel]];\n\n        const filteredStack = stackCopy.filter(\n          (cluster) => cluster.clusterTimestamp !== target.clusterTimestamp\n        );\n\n        dataCopy[target.group].chatData[target.channel] = filteredStack;\n        return dataCopy;\n      });\n    } else if (indexes) {\n      setGroupData((prevData) => {\n        const dataCopy = { ...prevData };\n        const stackCopy = [...dataCopy[target.group].chatData[target.channel]];\n        let indexModifier = 0;\n\n        const clusterIndex = stackCopy.findIndex(\n          (cluster) => cluster.clusterTimestamp === target.clusterTimestamp\n        );\n\n        if (clusterIndex < 0) {\n          // throw new Error(\"cluster not found\");\n          console.error(\"cluster not found\");\n          return null;\n        }\n\n        indexes.forEach((index) => {\n          stackCopy[clusterIndex].content.splice(index - indexModifier, 1);\n          indexModifier++;\n        });\n\n        dataCopy[target.group].chatData[target.channel] = stackCopy;\n        return dataCopy;\n      });\n    }\n  }\n\n  function getStatus(idString) {\n    return peerData[idString]?.status || \"offline\";\n  }\n\n  function mergePeers(partialData) {\n    setPeerData((prevData) => {\n      return { ...prevData, ...partialData };\n    });\n  }\n\n  function changeStatus(params) {\n    const { target, change } = params;\n\n    const validStatuses = [\"online\", \"away\", \"busy\", \"offline\"];\n    if (!validStatuses.includes(change)) {\n      // throw new Error(\"invalid status parameter\");\n      console.error(\"invalid status parameters\");\n      return null;\n    }\n    if (!target) {\n      // throw new Error(\"no id passed\");\n      console.error(\"id required\");\n      return null;\n    }\n\n    setPeerData((prevData) => {\n      const dataCopy = { ...prevData };\n\n      if (!dataCopy[target]) dataCopy[target] = { status: \"offline\" };\n      dataCopy[target].status = change;\n\n      return dataCopy;\n    });\n  }\n\n  function getLastInfo(groupId, channelId) {\n    const chatStack = groupData[groupId].chatData[channelId];\n\n    const elapsed =\n      chatStack.length > 0\n        ? Date.now() - chatStack[chatStack.length - 1].clusterTimestamp\n        : 0;\n\n    const lastSender =\n      chatStack.length > 0\n        ? chatStack[chatStack.length - 1].sender.username\n        : null;\n\n    const lastCluster =\n      chatStack.length > 0 ? chatStack[chatStack.length - 1] : null;\n\n    return { elapsed, lastCluster, lastSender };\n  }\n\n  const dataState = {\n    groupData,\n    setGroupData,\n    dataMounted,\n    setDataMounted,\n    chatMounted,\n    setChatMounted,\n    isLoggedIn,\n    setIsLoggedIn,\n    peerData,\n    setPeerData,\n    dataReady,\n    stateRestored,\n    setStateRestored,\n    mountChat,\n    selectedGroup,\n    setSelectedGroup,\n    selectedChannel,\n    setSelectedChannel,\n    windowIsFocused,\n    setWindowIsFocused,\n    clearSelected,\n    isAdmin,\n    selectedChatIsDepleted,\n    statusForced,\n    setStatusForced,\n    socketError,\n    setSocketError,\n\n    dataHelpers: {\n      getChannelIndex,\n      addNewGroup,\n      removeGroup,\n      patchGroup,\n      getLastInfo,\n      mergePeers,\n      removeClusterLocally,\n      getUnread,\n      setUnread,\n    },\n\n    peerHelpers: {\n      getStatus,\n      changeStatus,\n    },\n  };\n\n  return (\n    <DataContext.Provider value={dataState}>\n      {props.children}\n    </DataContext.Provider>\n  );\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}