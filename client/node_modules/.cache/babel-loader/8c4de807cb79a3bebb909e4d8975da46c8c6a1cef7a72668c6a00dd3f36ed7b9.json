{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useContext, useEffect, useRef } from \"react\";\nimport { DataContext } from \"../components/context/DataContext\";\nimport { SocketContext } from \"../components/context/SocketContext\";\nexport default function useSocket() {\n  _s();\n  const {\n    groupData,\n    setGroupData,\n    statusForced,\n    setStatusForced,\n    peerHelpers\n  } = useContext(DataContext);\n  const {\n    socket\n  } = useContext(SocketContext);\n  const userStatus = peerHelpers.getStatus(localStorage.userId);\n  const socketTimeout = 12000; // 12 secs\n  const awayTimeout = 180000; // 3 minutes\n\n  // stale closure fix\n  const socketRef = useRef(socket);\n  useEffect(() => {\n    socketRef.current = socket;\n  }, [socket]);\n  const statusForcedRef = useRef(statusForced);\n  useEffect(() => {\n    statusForcedRef.current = statusForced;\n  }, [statusForced]);\n\n  // timers\n  const mouseMoveTimerRef = useRef(null);\n  const awayTimerRef = useRef(null);\n\n  // update the server on user status change\n  function statusUpdater() {\n    function emitStatus(params) {\n      const {\n        status\n      } = params;\n      const validStatuses = [\"online\", \"away\", \"busy\", \"offline\"];\n      let effectiveSocket;\n      if (!validStatuses.includes(status)) throw new Error(\"invalid status parameter\");\n      if (socket) effectiveSocket = socket;else if (socketRef.current) {\n        effectiveSocket = socketRef.current;\n      } else {\n        // console.warn(\"socket not ready\");\n        return null;\n      }\n      effectiveSocket.emit(\"statusChange\", {\n        status\n      });\n    }\n    function setAwayTimeout() {\n      awayTimerRef.current = setTimeout(() => {\n        if (!statusForcedRef.current) emitStatus({\n          status: \"away\"\n        });\n        mouseMoveTimerRef.current = null;\n      }, awayTimeout);\n    }\n\n    // console.log(\"ref\", statusForcedRef.current, \"state\", statusForced); // always false\n    // big headache, turns out hooks like this are not like context providers, every time they're called,\n    // a new instance of this hook is created, so when the hook in userBadge updates it's forced state,\n    // the hook instance in the main window is not affected, and vice versa. Even refs don't update,\n    // because they are different instances, which is also why clearing timeouts doesn't work in the\n    // forceStatusUpdate function\n\n    // console.log(statusForcedRef.current);\n    // console.log(userStatus);\n\n    // if timer is not set, set it\n    if (!(mouseMoveTimerRef !== null && mouseMoveTimerRef !== void 0 && mouseMoveTimerRef.current)) {\n      if (!statusForcedRef.current && userStatus === \"away\") {\n        emitStatus({\n          status: \"online\"\n        });\n      }\n      mouseMoveTimerRef.current = Date.now();\n      setAwayTimeout();\n    }\n\n    // throttler, if time passed since last scroll evt <150ms ignore and reset away timer\n    else if (Date.now() - mouseMoveTimerRef.current < 150) {\n      mouseMoveTimerRef.current = Date.now();\n      clearTimeout(awayTimerRef.current);\n      setAwayTimeout();\n    }\n  }\n  function forceStatusUpdate(status) {\n    if (status === \"online\") setStatusForced(false);else setStatusForced(true);\n    socket.emit(\"statusChange\", {\n      status,\n      forced: status === \"online\" ? false : true\n    });\n    statusUpdater();\n  }\n  function sendMessage(args) {\n    const {\n      message,\n      target,\n      failed\n    } = args;\n    const genesisCluster = {\n      target,\n      data: message\n    };\n    const pendingCluster = {\n      sender: {\n        username: localStorage.username,\n        userImage: {\n          thumbnailMedium: localStorage.userImageMedium\n        }\n      },\n      channel: {},\n      content: [genesisCluster.data],\n      clusterTimestamp: message.timestamp\n    };\n\n    // push unsaved, non-failed cluster to message stack, failed messages property gets reset to null on retry\n    setGroupData(prevStack => {\n      const dataCopy = {\n        ...prevStack\n      };\n      const stackCopy = [...dataCopy[target.group].chatData[target.channel]];\n      if (!failed) stackCopy.push(pendingCluster);else {\n        const clusterIndex = stackCopy.findIndex(cluster => cluster.clusterTimestamp === message.timestamp);\n        stackCopy[clusterIndex].content[0].failed = null;\n      }\n      dataCopy[target.group].chatData[target.channel] = stackCopy;\n      return dataCopy;\n    });\n    function genesisAcknowledged(res) {\n      setGroupData(prevStack => {\n        // setState expression is used to access the latest pending state before rerender\n        // spread so that the values instead of the pointer is referenced by the new variable\n        // else state will see no change since the pointer doesn't change even if the values did\n        // make a copy of the whole chatData and the specific chat being modified\n        const dataCopy = {\n          ...prevStack\n        };\n        const stackCopy = [...dataCopy[res.target.group].chatData[res.target.channel]];\n        const clusterIndex = stackCopy.findIndex(message => message.clusterTimestamp === res.data.clusterTimestamp);\n        const contentCopy = stackCopy[clusterIndex].content;\n        contentCopy[0] = res.data.content[0];\n\n        // copy and move previous content with acknowledged content added\n        stackCopy[clusterIndex] = res.data;\n        stackCopy[clusterIndex].content = contentCopy;\n        dataCopy[res.target.group].chatData[res.target.channel] = stackCopy;\n        return dataCopy;\n      });\n    }\n    function genesisTimedOut() {\n      setGroupData(prevStack => {\n        const dataCopy = {\n          ...prevStack\n        };\n        const stackCopy = [...dataCopy[target.group].chatData[target.channel]];\n        const clusterIndex = stackCopy.findIndex(message => message.clusterTimestamp === pendingCluster.clusterTimestamp);\n        stackCopy[clusterIndex].content[0].failed = {\n          // was just setting {failed = res} here, that results in a circular reference that fails json.stringify in emit method\n          message: {\n            ...message\n          },\n          target: {\n            ...target\n          },\n          status: true\n        };\n        dataCopy[target.group].chatData[target.channel] = stackCopy;\n        return dataCopy;\n      });\n    }\n\n    // console.log(JSON.stringify(genesisCluster)); // emit fails with arg as failed object as it is a circular reference, fix by spread or reassigning\n\n    socket.timeout(socketTimeout).emit(\"newCluster\", {\n      ...genesisCluster\n    }, (err, res) => {\n      // set failed property on message if timed out or error\n      if (err) genesisTimedOut();else genesisAcknowledged(res);\n    });\n  }\n  function appendMessage(args) {\n    const {\n      message,\n      parent,\n      target,\n      failed\n    } = args;\n\n    // create an object with necessary info to send to api\n    const appendObject = {\n      target: {\n        cluster: {\n          timestamp: parent.clusterTimestamp ? parent.clusterTimestamp : null,\n          id: parent._id ? parent._id : null\n        },\n        group: target.group,\n        channel: target.channel\n      },\n      content: {\n        ...message\n      }\n    };\n\n    // find the index of the parent to be append locally,\n    let clusterIndex;\n    if (appendObject.target.cluster.id) {\n      clusterIndex = groupData[target.group].chatData[target.channel].findIndex(cluster => cluster._id === appendObject.target.cluster.id);\n    } else {\n      clusterIndex = groupData[target.group].chatData[target.channel].findIndex(cluster => cluster.clusterTimestamp === appendObject.target.cluster.timestamp);\n    }\n\n    // find index of pending message\n    let pendingIndex;\n    if (!failed) {\n      pendingIndex = groupData[target.group].chatData[target.channel][clusterIndex].content.length;\n    } else {\n      pendingIndex = groupData[target.group].chatData[target.channel][clusterIndex].content.findIndex(content => content.timestamp === message.timestamp);\n    }\n    appendObject.target.index = pendingIndex; // index of message in cluster for backend parity\n\n    // update local data with temporary data, if is a retry, reset failed property\n    setGroupData(prevStack => {\n      const dataCopy = {\n        ...prevStack\n      };\n      if (!failed) {\n        const updatedCluster = dataCopy[target.group].chatData[target.channel][clusterIndex];\n        updatedCluster.content.push(message);\n        dataCopy[target.group].chatData[target.channel][clusterIndex] = updatedCluster;\n      } else {\n        dataCopy[target.group].chatData[target.channel][clusterIndex].content[pendingIndex].failed = null;\n      }\n      return dataCopy;\n    });\n    function appendAcknowledged(res) {\n      setGroupData(prevStack => {\n        const dataCopy = {\n          ...prevStack\n        };\n        const stackCopy = [...prevStack[res.target.group].chatData[res.target.channel]];\n        const clusterIndex = stackCopy.findIndex(cluster => cluster.id === res.target.cluster.id);\n        const thisCluster = {\n          ...dataCopy[res.target.group].chatData[res.target.channel][clusterIndex]\n        };\n\n        // find pending message\n        const messageIndex = stackCopy[clusterIndex].content.findIndex(message => message.timestamp === (res.err ? res.err : res.data.timestamp)); // index always 0 because ternary and operator precedence, use parentheses to eval right side first\n\n        thisCluster.content[messageIndex] = res.data;\n        if (res.data.mentions.length > 0) {\n          res.data.mentions.forEach(newMention => {\n            const isNotMentioned = !thisCluster.mentions.some(existingMention => existingMention._id === newMention._id);\n            if (isNotMentioned) {\n              thisCluster.mentions.push(newMention);\n            }\n          });\n        }\n        dataCopy[res.target.group].chatData[res.target.channel][clusterIndex] = thisCluster;\n        return dataCopy;\n      });\n    }\n    function appendTimedOut() {\n      setGroupData(prevStack => {\n        const dataCopy = {\n          ...prevStack\n        };\n        const stackCopy = [...prevStack[target.group].chatData[target.channel]];\n        const clusterIndex = stackCopy.findIndex(cluster => cluster.clusterTimestamp === appendObject.target.cluster.timestamp);\n        dataCopy[target.group].chatData[target.channel][clusterIndex].content[appendObject.target.index].failed = {\n          message: {\n            ...message\n          },\n          parent: {\n            ...parent\n          },\n          target: {\n            ...target\n          },\n          status: true\n        };\n        return dataCopy;\n      });\n    }\n    socket.timeout(socketTimeout).emit(\"appendCluster\", appendObject, (err, res) => {\n      if (err || res.failed) appendTimedOut(); // handle err if append fails on backend with res.failed in addition to timeout\n      else appendAcknowledged(res);\n    });\n  }\n  function fetchMore(fetchParams) {\n    function patchChat(params) {\n      const {\n        partialChat,\n        target,\n        depleted = false\n      } = params;\n      setGroupData(prevData => {\n        const dataCopy = {\n          ...prevData\n        };\n        const groupCopy = {\n          ...dataCopy[target.group]\n        };\n        const stackCopy = [...groupCopy.chatData[target.channel]];\n        groupCopy.chatData[target.channel] = [...partialChat, ...stackCopy];\n        if (depleted) {\n          groupCopy.chatDepleted[target.channel] = true;\n        }\n        dataCopy[target.group] = groupCopy;\n        return dataCopy;\n      });\n    }\n    function fetchReceived(res) {\n      patchChat({\n        partialChat: res.data,\n        target: res.target,\n        depleted: res.depleted\n      });\n    }\n    return new Promise((resolve, reject) => {\n      resolve(socket.timeout(socketTimeout).emit(\"fetchMore\", fetchParams, (err, res) => {\n        if (err || res.failed) return {\n          err: \"timed out\"\n        };else fetchReceived(res);\n      }));\n    });\n  }\n  return {\n    sendMessage,\n    appendMessage,\n    fetchMore,\n    statusUpdater,\n    forceStatusUpdate\n  };\n}\n_s(useSocket, \"bKUCbZLVwUFP1McvYrTGcjSc5J4=\");","map":{"version":3,"names":["useContext","useEffect","useRef","DataContext","SocketContext","useSocket","groupData","setGroupData","statusForced","setStatusForced","peerHelpers","socket","userStatus","getStatus","localStorage","userId","socketTimeout","awayTimeout","socketRef","current","statusForcedRef","mouseMoveTimerRef","awayTimerRef","statusUpdater","emitStatus","params","status","validStatuses","effectiveSocket","includes","Error","emit","setAwayTimeout","setTimeout","Date","now","clearTimeout","forceStatusUpdate","forced","sendMessage","args","message","target","failed","genesisCluster","data","pendingCluster","sender","username","userImage","thumbnailMedium","userImageMedium","channel","content","clusterTimestamp","timestamp","prevStack","dataCopy","stackCopy","group","chatData","push","clusterIndex","findIndex","cluster","genesisAcknowledged","res","contentCopy","genesisTimedOut","timeout","err","appendMessage","parent","appendObject","id","_id","pendingIndex","length","index","updatedCluster","appendAcknowledged","thisCluster","messageIndex","mentions","forEach","newMention","isNotMentioned","some","existingMention","appendTimedOut","fetchMore","fetchParams","patchChat","partialChat","depleted","prevData","groupCopy","chatDepleted","fetchReceived","Promise","resolve","reject"],"sources":["/home/agreus/Documents/webdev/mercury-messenger/client/src/utils/socket.js"],"sourcesContent":["import { useContext, useEffect, useRef } from \"react\";\n\nimport { DataContext } from \"../components/context/DataContext\";\nimport { SocketContext } from \"../components/context/SocketContext\";\n\nexport default function useSocket() {\n  const {\n    groupData,\n    setGroupData,\n    statusForced,\n    setStatusForced,\n    peerHelpers,\n  } = useContext(DataContext);\n  const { socket } = useContext(SocketContext);\n\n  const userStatus = peerHelpers.getStatus(localStorage.userId);\n\n  const socketTimeout = 12000; // 12 secs\n  const awayTimeout = 180000; // 3 minutes\n\n  // stale closure fix\n  const socketRef = useRef(socket);\n  useEffect(() => {\n    socketRef.current = socket;\n  }, [socket]);\n  const statusForcedRef = useRef(statusForced);\n  useEffect(() => {\n    statusForcedRef.current = statusForced;\n  }, [statusForced]);\n\n  // timers\n  const mouseMoveTimerRef = useRef(null);\n  const awayTimerRef = useRef(null);\n\n  // update the server on user status change\n  function statusUpdater() {\n    function emitStatus(params) {\n      const { status } = params;\n      const validStatuses = [\"online\", \"away\", \"busy\", \"offline\"];\n      let effectiveSocket;\n\n      if (!validStatuses.includes(status))\n        throw new Error(\"invalid status parameter\");\n\n      if (socket) effectiveSocket = socket;\n      else if (socketRef.current) {\n        effectiveSocket = socketRef.current;\n      } else {\n        // console.warn(\"socket not ready\");\n        return null;\n      }\n\n      effectiveSocket.emit(\"statusChange\", { status });\n    }\n\n    function setAwayTimeout() {\n      awayTimerRef.current = setTimeout(() => {\n        if (!statusForcedRef.current) emitStatus({ status: \"away\" });\n        mouseMoveTimerRef.current = null;\n      }, awayTimeout);\n    }\n\n    // console.log(\"ref\", statusForcedRef.current, \"state\", statusForced); // always false\n    // big headache, turns out hooks like this are not like context providers, every time they're called,\n    // a new instance of this hook is created, so when the hook in userBadge updates it's forced state,\n    // the hook instance in the main window is not affected, and vice versa. Even refs don't update,\n    // because they are different instances, which is also why clearing timeouts doesn't work in the\n    // forceStatusUpdate function\n\n    // console.log(statusForcedRef.current);\n    // console.log(userStatus);\n\n    // if timer is not set, set it\n    if (!mouseMoveTimerRef?.current) {\n      if (!statusForcedRef.current && userStatus === \"away\") {\n        emitStatus({ status: \"online\" });\n      }\n      mouseMoveTimerRef.current = Date.now();\n      setAwayTimeout();\n    }\n\n    // throttler, if time passed since last scroll evt <150ms ignore and reset away timer\n    else if (Date.now() - mouseMoveTimerRef.current < 150) {\n      mouseMoveTimerRef.current = Date.now();\n      clearTimeout(awayTimerRef.current);\n      setAwayTimeout();\n    }\n  }\n\n  function forceStatusUpdate(status) {\n    if (status === \"online\") setStatusForced(false);\n    else setStatusForced(true);\n\n    socket.emit(\"statusChange\", {\n      status,\n      forced: status === \"online\" ? false : true,\n    });\n    statusUpdater();\n  }\n\n  function sendMessage(args) {\n    const { message, target, failed } = args;\n    const genesisCluster = { target, data: message };\n    const pendingCluster = {\n      sender: {\n        username: localStorage.username,\n        userImage: {\n          thumbnailMedium: localStorage.userImageMedium,\n        },\n      },\n      channel: {},\n      content: [genesisCluster.data],\n      clusterTimestamp: message.timestamp,\n    };\n\n    // push unsaved, non-failed cluster to message stack, failed messages property gets reset to null on retry\n    setGroupData((prevStack) => {\n      const dataCopy = { ...prevStack };\n      const stackCopy = [...dataCopy[target.group].chatData[target.channel]];\n\n      if (!failed) stackCopy.push(pendingCluster);\n      else {\n        const clusterIndex = stackCopy.findIndex(\n          (cluster) => cluster.clusterTimestamp === message.timestamp\n        );\n\n        stackCopy[clusterIndex].content[0].failed = null;\n      }\n\n      dataCopy[target.group].chatData[target.channel] = stackCopy;\n\n      return dataCopy;\n    });\n\n    function genesisAcknowledged(res) {\n      setGroupData((prevStack) => {\n        // setState expression is used to access the latest pending state before rerender\n        // spread so that the values instead of the pointer is referenced by the new variable\n        // else state will see no change since the pointer doesn't change even if the values did\n        // make a copy of the whole chatData and the specific chat being modified\n        const dataCopy = { ...prevStack };\n        const stackCopy = [\n          ...dataCopy[res.target.group].chatData[res.target.channel],\n        ];\n\n        const clusterIndex = stackCopy.findIndex(\n          (message) => message.clusterTimestamp === res.data.clusterTimestamp\n        );\n\n        const contentCopy = stackCopy[clusterIndex].content;\n\n        contentCopy[0] = res.data.content[0];\n\n        // copy and move previous content with acknowledged content added\n        stackCopy[clusterIndex] = res.data;\n        stackCopy[clusterIndex].content = contentCopy;\n\n        dataCopy[res.target.group].chatData[res.target.channel] = stackCopy;\n\n        return dataCopy;\n      });\n    }\n\n    function genesisTimedOut() {\n      setGroupData((prevStack) => {\n        const dataCopy = { ...prevStack };\n        const stackCopy = [...dataCopy[target.group].chatData[target.channel]];\n\n        const clusterIndex = stackCopy.findIndex(\n          (message) =>\n            message.clusterTimestamp === pendingCluster.clusterTimestamp\n        );\n\n        stackCopy[clusterIndex].content[0].failed = {\n          // was just setting {failed = res} here, that results in a circular reference that fails json.stringify in emit method\n          message: { ...message },\n          target: { ...target },\n          status: true,\n        };\n\n        dataCopy[target.group].chatData[target.channel] = stackCopy;\n\n        return dataCopy;\n      });\n    }\n\n    // console.log(JSON.stringify(genesisCluster)); // emit fails with arg as failed object as it is a circular reference, fix by spread or reassigning\n\n    socket\n      .timeout(socketTimeout)\n      .emit(\"newCluster\", { ...genesisCluster }, (err, res) => {\n        // set failed property on message if timed out or error\n        if (err) genesisTimedOut();\n        else genesisAcknowledged(res);\n      });\n  }\n\n  function appendMessage(args) {\n    const { message, parent, target, failed } = args;\n\n    // create an object with necessary info to send to api\n    const appendObject = {\n      target: {\n        cluster: {\n          timestamp: parent.clusterTimestamp ? parent.clusterTimestamp : null,\n          id: parent._id ? parent._id : null,\n        },\n        group: target.group,\n        channel: target.channel,\n      },\n      content: { ...message },\n    };\n\n    // find the index of the parent to be append locally,\n    let clusterIndex;\n    if (appendObject.target.cluster.id) {\n      clusterIndex = groupData[target.group].chatData[target.channel].findIndex(\n        (cluster) => cluster._id === appendObject.target.cluster.id\n      );\n    } else {\n      clusterIndex = groupData[target.group].chatData[target.channel].findIndex(\n        (cluster) =>\n          cluster.clusterTimestamp === appendObject.target.cluster.timestamp\n      );\n    }\n\n    // find index of pending message\n    let pendingIndex;\n    if (!failed) {\n      pendingIndex =\n        groupData[target.group].chatData[target.channel][clusterIndex].content\n          .length;\n    } else {\n      pendingIndex = groupData[target.group].chatData[target.channel][\n        clusterIndex\n      ].content.findIndex((content) => content.timestamp === message.timestamp);\n    }\n\n    appendObject.target.index = pendingIndex; // index of message in cluster for backend parity\n\n    // update local data with temporary data, if is a retry, reset failed property\n    setGroupData((prevStack) => {\n      const dataCopy = { ...prevStack };\n\n      if (!failed) {\n        const updatedCluster =\n          dataCopy[target.group].chatData[target.channel][clusterIndex];\n        updatedCluster.content.push(message);\n\n        dataCopy[target.group].chatData[target.channel][clusterIndex] =\n          updatedCluster;\n      } else {\n        dataCopy[target.group].chatData[target.channel][clusterIndex].content[\n          pendingIndex\n        ].failed = null;\n      }\n\n      return dataCopy;\n    });\n\n    function appendAcknowledged(res) {\n      setGroupData((prevStack) => {\n        const dataCopy = { ...prevStack };\n        const stackCopy = [\n          ...prevStack[res.target.group].chatData[res.target.channel],\n        ];\n\n        const clusterIndex = stackCopy.findIndex(\n          (cluster) => cluster.id === res.target.cluster.id\n        );\n\n        const thisCluster = {\n          ...dataCopy[res.target.group].chatData[res.target.channel][\n            clusterIndex\n          ],\n        };\n\n        // find pending message\n        const messageIndex = stackCopy[clusterIndex].content.findIndex(\n          (message) =>\n            message.timestamp === (res.err ? res.err : res.data.timestamp)\n        ); // index always 0 because ternary and operator precedence, use parentheses to eval right side first\n\n        thisCluster.content[messageIndex] = res.data;\n\n        if (res.data.mentions.length > 0) {\n          res.data.mentions.forEach((newMention) => {\n            const isNotMentioned = !thisCluster.mentions.some(\n              (existingMention) => existingMention._id === newMention._id\n            );\n\n            if (isNotMentioned) {\n              thisCluster.mentions.push(newMention);\n            }\n          });\n        }\n\n        dataCopy[res.target.group].chatData[res.target.channel][clusterIndex] =\n          thisCluster;\n\n        return dataCopy;\n      });\n    }\n\n    function appendTimedOut() {\n      setGroupData((prevStack) => {\n        const dataCopy = { ...prevStack };\n        const stackCopy = [...prevStack[target.group].chatData[target.channel]];\n\n        const clusterIndex = stackCopy.findIndex(\n          (cluster) =>\n            cluster.clusterTimestamp === appendObject.target.cluster.timestamp\n        );\n\n        dataCopy[target.group].chatData[target.channel][clusterIndex].content[\n          appendObject.target.index\n        ].failed = {\n          message: { ...message },\n          parent: { ...parent },\n          target: { ...target },\n          status: true,\n        };\n\n        return dataCopy;\n      });\n    }\n\n    socket\n      .timeout(socketTimeout)\n      .emit(\"appendCluster\", appendObject, (err, res) => {\n        if (err || res.failed)\n          appendTimedOut(); // handle err if append fails on backend with res.failed in addition to timeout\n        else appendAcknowledged(res);\n      });\n  }\n\n  function fetchMore(fetchParams) {\n    function patchChat(params) {\n      const { partialChat, target, depleted = false } = params;\n\n      setGroupData((prevData) => {\n        const dataCopy = { ...prevData };\n        const groupCopy = { ...dataCopy[target.group] };\n        const stackCopy = [...groupCopy.chatData[target.channel]];\n\n        groupCopy.chatData[target.channel] = [...partialChat, ...stackCopy];\n        if (depleted) {\n          groupCopy.chatDepleted[target.channel] = true;\n        }\n\n        dataCopy[target.group] = groupCopy;\n\n        return dataCopy;\n      });\n    }\n\n    function fetchReceived(res) {\n      patchChat({\n        partialChat: res.data,\n        target: res.target,\n        depleted: res.depleted,\n      });\n    }\n\n    return new Promise((resolve, reject) => {\n      resolve(\n        socket\n          .timeout(socketTimeout)\n          .emit(\"fetchMore\", fetchParams, (err, res) => {\n            if (err || res.failed) return { err: \"timed out\" };\n            else fetchReceived(res);\n          })\n      );\n    });\n  }\n\n  return {\n    sendMessage,\n    appendMessage,\n    fetchMore,\n    statusUpdater,\n    forceStatusUpdate,\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}