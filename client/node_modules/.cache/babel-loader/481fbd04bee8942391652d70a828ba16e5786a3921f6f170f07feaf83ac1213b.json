{"ast":null,"code":"var _jsxFileName = \"/home/agreus/Documents/webdev/mercury-messenger/client/src/components/context/SocketContext.js\",\n  _s = $RefreshSig$();\nimport { useState, createContext, useContext, useEffect, useRef } from \"react\";\nimport { useNavigate } from \"react-router-dom\";\nimport { io } from \"socket.io-client\";\n\n// context\nimport { FlashContext } from \"./FlashContext\";\nimport { DataContext } from \"./DataContext\";\n\n// utility hooks\nimport axiosInstance from \"../../utils/axios\";\nimport config from \"../../config\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const SocketContext = /*#__PURE__*/createContext();\nexport function SocketStateProvider(props) {\n  _s();\n  const [socket, setSocket] = useState(null);\n  const [socketStatus, setSocketStatus] = useState({\n    connected: false,\n    message: null,\n    code: null\n  });\n  const {\n    pushFlashMessage\n  } = useContext(FlashContext);\n  const {\n    windowIsFocused,\n    selectedChannel,\n    selectedGroup,\n    setSelectedChannel,\n    setSelectedGroup,\n    clearSelected,\n    setGroupData,\n    setChatMounted,\n    dataMounted,\n    setDataMounted,\n    mountChat,\n    setPeerData,\n    dataHelpers,\n    isLoggedIn,\n    setIsLoggedIn,\n    setStatusForced,\n    peerHelpers,\n    setSocketError\n  } = useContext(DataContext);\n  const {\n    userGroups\n  } = axiosInstance();\n\n  // these refs are used to provide the latest values and fix stale closures in socket events\n  const selectedGroupRef = useRef(selectedGroup);\n  const selectedChannelRef = useRef(selectedChannel);\n  useEffect(() => {\n    selectedGroupRef.current = selectedGroup;\n    selectedChannelRef.current = selectedChannel;\n  }, [selectedGroup, selectedChannel]);\n  const navigate = useNavigate();\n  const notification = new Audio(\"/beep.mp3\");\n\n  // initial socket io connection\n  useEffect(() => {\n    if (isLoggedIn && !socketStatus.connected) {\n      connectSocket();\n    }\n    return () => {\n      socket === null || socket === void 0 ? void 0 : socket.disconnect();\n      setSocketStatus({\n        connected: false,\n        message: null,\n        code: null\n      });\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [isLoggedIn, dataMounted]);\n  function connectSocket() {\n    setSocket(io(config.ORIGIN, {\n      withCredentials: true\n    }));\n  }\n  function socketClear() {\n    if (socket !== null) socket.disconnect();\n    setSocket(null);\n    setSocketStatus({\n      connected: true,\n      message: null,\n      code: null\n    });\n  }\n\n  // this should only run once to avoid multiple instances of socket event listeners\n  // this check avoids duplicate listeners\n  // stale closure issue here, solved with refs, alternatively if in useEffect, ensure proper dependencies\n  if (socket && !(socket !== null && socket !== void 0 && socket._callbacks)) {\n    socket.on(\"connect\", function /*don't redefine socket here*/\n    () {\n      // \"connect\" not \"connected\"\n\n      userGroups.fetch().then(res => {\n        const groupData = res.data;\n        setGroupData(() => groupData);\n        socket.emit(\"requestInitData\", {}, (res, err) => {\n          if (err || res.failed) return err;else {\n            setPeerData(res.peerData);\n            if (res.peerData[localStorage.userId].status !== \"online\") {\n              setStatusForced(true);\n            }\n            mountChat(res.chatData, res.chatDepleted);\n          }\n        });\n        setSocketError(null);\n        setDataMounted(true);\n      }).catch(e => e); // axios abort throws error unless it's caught here\n\n      setSocketStatus({\n        connected: true,\n        code: null,\n        message: null\n      });\n    });\n    socket.on(\"disconnect\", res => {\n      if (res === \"transport close\") {\n        setSocketError(\"server unavailable\");\n      } else if (res === \"io server disconnect\") {\n        setSocketError(\"click to use on this device\");\n      }\n      setChatMounted(false);\n      setSocketStatus({\n        connected: false,\n        code: 503,\n        message: null\n      });\n    });\n    socket.on(\"connect_error\", err => {\n      if (err.message === \"xhr poll error\") {\n        setSocketStatus({\n          connected: false,\n          message: \"Server unreachable\",\n          code: 503\n        });\n      } else if (err.data.code === 403) {\n        setSocketStatus({\n          connected: false,\n          message: err.data.message,\n          code: err.data.code\n        });\n      } else if (err.data.code === 401) {\n        setIsLoggedIn(false);\n      }\n    });\n    socket.on(\"newMessage\", function (res) {\n      var _selectedChannelRef$c;\n      const channelIsFocused = ((_selectedChannelRef$c = selectedChannelRef.current) === null || _selectedChannelRef$c === void 0 ? void 0 : _selectedChannelRef$c._id) === res.channel._id;\n      if (!windowIsFocused || !channelIsFocused) {\n        notification.play();\n      }\n      if (!channelIsFocused) {\n        dataHelpers.setUnread({\n          add: true,\n          channelId: res.channel._id\n        });\n      }\n      setGroupData(prevData => {\n        const dataCopy = {\n          ...prevData\n        };\n        dataCopy[res.group._id].chatData[res.channel._id].push(res);\n        return dataCopy;\n      });\n    });\n    socket.on(\"appendMessage\", function (res) {\n      var _selectedChannelRef$c2;\n      const channelIsFocused = ((_selectedChannelRef$c2 = selectedChannelRef.current) === null || _selectedChannelRef$c2 === void 0 ? void 0 : _selectedChannelRef$c2._id) === res.target.channel;\n      if (windowIsFocused || !channelIsFocused) {\n        notification.play();\n      }\n      setGroupData(prevStack => {\n        const dataCopy = {\n          ...prevStack\n        };\n        const stackCopy = dataCopy[res.target.group].chatData[res.target.channel];\n        const clusterIndex = stackCopy.findIndex(cluster => cluster._id === res.target.cluster.id);\n\n        // update stack to contain verified message\n        stackCopy[clusterIndex].content[res.target.index] = res.data;\n\n        // update mentions\n        if (res.data.mentions.length > 0) {\n          const mentionsCopy = stackCopy[clusterIndex].mentions;\n\n          // add new mentions if has not been mentioned before\n          res.data.mentions.forEach(user => {\n            const isNotMentioned = !mentionsCopy.some(existingUser => existingUser._id === user._id);\n            if (isNotMentioned) {\n              mentionsCopy.push(user);\n            }\n          });\n        }\n        dataCopy[res.target.group].chatData[res.target.channel] = stackCopy;\n        return dataCopy;\n      });\n    });\n    socket.on(\"structureChange\", function (res) {\n      const {\n        target,\n        change,\n        messages\n      } = res;\n\n      // console.log(selectedGroup);\n      // console.log(`${change.type} signal received`);\n      // console.log(res);\n\n      function createChannel() {\n        setGroupData(currentData => {\n          const dataCopy = {\n            ...currentData\n          };\n          dataCopy[target.parent].channels.text.push(change.data);\n          dataCopy[target.parent].chatData[target.id] = [];\n          return dataCopy;\n        });\n      }\n      function editChannel() {\n        var _selectedChannelRef$c3;\n        setGroupData(currentData => {\n          const dataCopy = {\n            ...currentData\n          };\n          const channelIndex = dataHelpers.getChannelIndex(target.parent, target.id);\n          dataCopy[target.parent].channels.text[channelIndex] = change.data;\n          return dataCopy;\n        });\n        if (((_selectedChannelRef$c3 = selectedChannelRef.current) === null || _selectedChannelRef$c3 === void 0 ? void 0 : _selectedChannelRef$c3._id) === target.id) {\n          setSelectedChannel(change.data);\n          navigate(`/g/${selectedGroupRef.current.name}/c/${change.data.name}`);\n        }\n      }\n      function deleteChannel() {\n        var _selectedChannelRef$c4;\n        setGroupData(currentData => {\n          const dataCopy = {\n            ...currentData\n          };\n          const channelIndex = dataHelpers.getChannelIndex(target.parent, target.id);\n          dataCopy[target.parent].channels.text.splice(channelIndex, 1);\n          delete dataCopy[target.parent].chatData[target.id];\n          return dataCopy;\n        });\n        if (((_selectedChannelRef$c4 = selectedChannelRef.current) === null || _selectedChannelRef$c4 === void 0 ? void 0 : _selectedChannelRef$c4._id) === target.id) {\n          setSelectedChannel(null);\n          navigate(`/g/${selectedGroupRef.current.name}`);\n        }\n      }\n      function createGroup() {\n        setGroupData(currentData => {\n          const dataCopy = {\n            ...currentData\n          };\n          dataCopy.push(change.data);\n          dataCopy[target.parent].chatData[target.id] = [];\n          return dataCopy;\n        });\n      }\n      function editGroup() {\n        var _change$extra, _change$extra$toKick, _selectedGroupRef$cur;\n        const isKicked = (_change$extra = change.extra) === null || _change$extra === void 0 ? void 0 : (_change$extra$toKick = _change$extra.toKick) === null || _change$extra$toKick === void 0 ? void 0 : _change$extra$toKick.includes(localStorage.userId);\n        setGroupData(currentData => {\n          const dataCopy = {\n            ...currentData\n          };\n          if (isKicked) delete dataCopy[target.id];else {\n            // move old chat to new group\n            const chatCopy = dataCopy[target.id].chatData;\n            dataCopy[target.id] = change.data;\n            dataCopy[target.id].chatData = chatCopy;\n          }\n          return dataCopy;\n        });\n        if (((_selectedGroupRef$cur = selectedGroupRef.current) === null || _selectedGroupRef$cur === void 0 ? void 0 : _selectedGroupRef$cur._id) === target.id) {\n          if (isKicked) {\n            setSelectedGroup(null);\n            setSelectedChannel(null);\n            navigate(\"/\");\n          } else {\n            setSelectedGroup(change.data);\n\n            // reroute to updated, depending on if in channel\n            if (selectedChannelRef.current) {\n              navigate(`/g/${change.data.name}/c/${selectedChannelRef.current.name}`);\n            } else {\n              navigate(`/g/${change.data.name}`);\n            }\n          }\n        }\n      }\n      function deleteGroup() {\n        var _selectedGroupRef$cur2;\n        setGroupData(currentData => {\n          const dataCopy = {\n            ...currentData\n          };\n          delete dataCopy[target.id];\n          return dataCopy;\n        });\n        if (((_selectedGroupRef$cur2 = selectedGroupRef.current) === null || _selectedGroupRef$cur2 === void 0 ? void 0 : _selectedGroupRef$cur2._id) === target.id) {\n          clearSelected();\n          navigate(`/`);\n        }\n      }\n      function joinedGroup() {\n        setGroupData(currentData => {\n          const dataCopy = {\n            ...currentData\n          };\n          dataCopy[target.id].members.push(change.extra.user);\n          return dataCopy;\n        });\n        dataHelpers.mergePeers(change.extra.partialPeerData);\n      }\n      function leftGroup(params) {\n        setGroupData(currentData => {\n          const dataCopy = {\n            ...currentData\n          };\n          dataCopy[target.id].members = dataCopy[target.id].members.filter(member => member._id !== change.extra.userId);\n          dataCopy[target.id].administrators = dataCopy[target.id].members.filter(admin => admin._id !== change.extra.userId);\n          return dataCopy;\n        });\n      }\n\n      // function editMessage() {} // todo\n\n      // function deleteMessage() {} // todo\n\n      if (messages.length > 0) pushFlashMessage(messages); // transfer any messages to context\n\n      if (target.type === \"channel\") {\n        if (change.type === \"create\") createChannel();else if (change.type === \"edit\") editChannel();else if (change.type === \"delete\") deleteChannel();\n      } else if (target.type === \"group\") {\n        if (change.type === \"create\") createGroup();else if (change.type === \"edit\") editGroup();else if (change.type === \"delete\") deleteGroup();else if (change.type === \"join\") joinedGroup();else if (change.type === \"leave\") leftGroup();\n      }\n      // else if (target.type === \"message\") {\n      //   if (change.type === \"edit\") editMessage();\n      //   else if (change.type === \"delete\") deleteMessage();\n      // }\n    });\n\n    socket.on(\"statusChange\", res => {\n      peerHelpers.changeStatus({\n        target: res.target,\n        change: res.change\n      });\n    });\n  }\n  const socketInstance = {\n    socket,\n    connectSocket,\n    socketStatus,\n    socketClear\n  };\n  return /*#__PURE__*/_jsxDEV(SocketContext.Provider, {\n    value: socketInstance,\n    children: props.children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 388,\n    columnNumber: 5\n  }, this);\n}\n_s(SocketStateProvider, \"D+a+nfVGafM5RN79ktXKEPOFhKs=\", false, function () {\n  return [useNavigate];\n});\n_c = SocketStateProvider;\nvar _c;\n$RefreshReg$(_c, \"SocketStateProvider\");","map":{"version":3,"names":["useState","createContext","useContext","useEffect","useRef","useNavigate","io","FlashContext","DataContext","axiosInstance","config","SocketContext","SocketStateProvider","props","socket","setSocket","socketStatus","setSocketStatus","connected","message","code","pushFlashMessage","windowIsFocused","selectedChannel","selectedGroup","setSelectedChannel","setSelectedGroup","clearSelected","setGroupData","setChatMounted","dataMounted","setDataMounted","mountChat","setPeerData","dataHelpers","isLoggedIn","setIsLoggedIn","setStatusForced","peerHelpers","setSocketError","userGroups","selectedGroupRef","selectedChannelRef","current","navigate","notification","Audio","connectSocket","disconnect","ORIGIN","withCredentials","socketClear","_callbacks","on","fetch","then","res","groupData","data","emit","err","failed","peerData","localStorage","userId","status","chatData","chatDepleted","catch","e","channelIsFocused","_id","channel","play","setUnread","add","channelId","prevData","dataCopy","group","push","target","prevStack","stackCopy","clusterIndex","findIndex","cluster","id","content","index","mentions","length","mentionsCopy","forEach","user","isNotMentioned","some","existingUser","change","messages","createChannel","currentData","parent","channels","text","editChannel","channelIndex","getChannelIndex","name","deleteChannel","splice","createGroup","editGroup","isKicked","extra","toKick","includes","chatCopy","deleteGroup","joinedGroup","members","mergePeers","partialPeerData","leftGroup","params","filter","member","administrators","admin","type","changeStatus","socketInstance","children"],"sources":["/home/agreus/Documents/webdev/mercury-messenger/client/src/components/context/SocketContext.js"],"sourcesContent":["import { useState, createContext, useContext, useEffect, useRef } from \"react\";\nimport { useNavigate } from \"react-router-dom\";\nimport { io } from \"socket.io-client\";\n\n// context\nimport { FlashContext } from \"./FlashContext\";\nimport { DataContext } from \"./DataContext\";\n\n// utility hooks\nimport axiosInstance from \"../../utils/axios\";\n\nimport config from \"../../config\";\n\nexport const SocketContext = createContext();\n\nexport function SocketStateProvider(props) {\n  const [socket, setSocket] = useState(null);\n  const [socketStatus, setSocketStatus] = useState({\n    connected: false,\n    message: null,\n    code: null,\n  });\n  const { pushFlashMessage } = useContext(FlashContext);\n\n  const {\n    windowIsFocused,\n    selectedChannel,\n    selectedGroup,\n    setSelectedChannel,\n    setSelectedGroup,\n    clearSelected,\n    setGroupData,\n    setChatMounted,\n    dataMounted,\n    setDataMounted,\n    mountChat,\n    setPeerData,\n    dataHelpers,\n    isLoggedIn,\n    setIsLoggedIn,\n    setStatusForced,\n    peerHelpers,\n    setSocketError,\n  } = useContext(DataContext);\n\n  const { userGroups } = axiosInstance();\n\n  // these refs are used to provide the latest values and fix stale closures in socket events\n  const selectedGroupRef = useRef(selectedGroup);\n  const selectedChannelRef = useRef(selectedChannel);\n  useEffect(() => {\n    selectedGroupRef.current = selectedGroup;\n    selectedChannelRef.current = selectedChannel;\n  }, [selectedGroup, selectedChannel]);\n\n  const navigate = useNavigate();\n  const notification = new Audio(\"/beep.mp3\");\n\n  // initial socket io connection\n  useEffect(() => {\n    if (isLoggedIn && !socketStatus.connected) {\n      connectSocket();\n    }\n    return () => {\n      socket?.disconnect();\n      setSocketStatus({\n        connected: false,\n        message: null,\n        code: null,\n      });\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [isLoggedIn, dataMounted]);\n\n  function connectSocket() {\n    setSocket(\n      io(config.ORIGIN, {\n        withCredentials: true,\n      })\n    );\n  }\n\n  function socketClear() {\n    if (socket !== null) socket.disconnect();\n    setSocket(null);\n    setSocketStatus({ connected: true, message: null, code: null });\n  }\n\n  // this should only run once to avoid multiple instances of socket event listeners\n  // this check avoids duplicate listeners\n  // stale closure issue here, solved with refs, alternatively if in useEffect, ensure proper dependencies\n  if (socket && !socket?._callbacks) {\n    socket.on(\"connect\", function (/*don't redefine socket here*/) {\n      // \"connect\" not \"connected\"\n\n      userGroups\n        .fetch()\n        .then((res) => {\n          const groupData = res.data;\n\n          setGroupData(() => groupData);\n\n          socket.emit(\"requestInitData\", {}, (res, err) => {\n            if (err || res.failed) return err;\n            else {\n              setPeerData(res.peerData);\n              if (res.peerData[localStorage.userId].status !== \"online\") {\n                setStatusForced(true);\n              }\n              mountChat(res.chatData, res.chatDepleted);\n            }\n          });\n\n          setSocketError(null);\n          setDataMounted(true);\n        })\n        .catch((e) => e); // axios abort throws error unless it's caught here\n\n      setSocketStatus({ connected: true, code: null, message: null });\n    });\n\n    socket.on(\"disconnect\", (res) => {\n      if (res === \"transport close\") {\n        setSocketError(\"server unavailable\");\n      } else if (res === \"io server disconnect\") {\n        setSocketError(\"click to use on this device\");\n      }\n\n      setChatMounted(false);\n      setSocketStatus({ connected: false, code: 503, message: null });\n    });\n\n    socket.on(\"connect_error\", (err) => {\n      if (err.message === \"xhr poll error\") {\n        setSocketStatus({\n          connected: false,\n          message: \"Server unreachable\",\n          code: 503,\n        });\n      } else if (err.data.code === 403) {\n        setSocketStatus({\n          connected: false,\n          message: err.data.message,\n          code: err.data.code,\n        });\n      } else if (err.data.code === 401) {\n        setIsLoggedIn(false);\n      }\n    });\n\n    socket.on(\"newMessage\", function (res) {\n      const channelIsFocused =\n        selectedChannelRef.current?._id === res.channel._id;\n\n      if (!windowIsFocused || !channelIsFocused) {\n        notification.play();\n      }\n\n      if (!channelIsFocused) {\n        dataHelpers.setUnread({ add: true, channelId: res.channel._id });\n      }\n\n      setGroupData((prevData) => {\n        const dataCopy = { ...prevData };\n\n        dataCopy[res.group._id].chatData[res.channel._id].push(res);\n        return dataCopy;\n      });\n    });\n\n    socket.on(\"appendMessage\", function (res) {\n      const channelIsFocused =\n        selectedChannelRef.current?._id === res.target.channel;\n\n      if (windowIsFocused || !channelIsFocused) {\n        notification.play();\n      }\n\n      setGroupData((prevStack) => {\n        const dataCopy = { ...prevStack };\n        const stackCopy =\n          dataCopy[res.target.group].chatData[res.target.channel];\n\n        const clusterIndex = stackCopy.findIndex(\n          (cluster) => cluster._id === res.target.cluster.id\n        );\n\n        // update stack to contain verified message\n        stackCopy[clusterIndex].content[res.target.index] = res.data;\n\n        // update mentions\n        if (res.data.mentions.length > 0) {\n          const mentionsCopy = stackCopy[clusterIndex].mentions;\n\n          // add new mentions if has not been mentioned before\n          res.data.mentions.forEach((user) => {\n            const isNotMentioned = !mentionsCopy.some(\n              (existingUser) => existingUser._id === user._id\n            );\n\n            if (isNotMentioned) {\n              mentionsCopy.push(user);\n            }\n          });\n        }\n\n        dataCopy[res.target.group].chatData[res.target.channel] = stackCopy;\n\n        return dataCopy;\n      });\n    });\n\n    socket.on(\"structureChange\", function (res) {\n      const { target, change, messages } = res;\n\n      // console.log(selectedGroup);\n      // console.log(`${change.type} signal received`);\n      // console.log(res);\n\n      function createChannel() {\n        setGroupData((currentData) => {\n          const dataCopy = { ...currentData };\n\n          dataCopy[target.parent].channels.text.push(change.data);\n          dataCopy[target.parent].chatData[target.id] = [];\n          return dataCopy;\n        });\n      }\n\n      function editChannel() {\n        setGroupData((currentData) => {\n          const dataCopy = { ...currentData };\n          const channelIndex = dataHelpers.getChannelIndex(\n            target.parent,\n            target.id\n          );\n\n          dataCopy[target.parent].channels.text[channelIndex] = change.data;\n          return dataCopy;\n        });\n\n        if (selectedChannelRef.current?._id === target.id) {\n          setSelectedChannel(change.data);\n          navigate(`/g/${selectedGroupRef.current.name}/c/${change.data.name}`);\n        }\n      }\n\n      function deleteChannel() {\n        setGroupData((currentData) => {\n          const dataCopy = { ...currentData };\n          const channelIndex = dataHelpers.getChannelIndex(\n            target.parent,\n            target.id\n          );\n\n          dataCopy[target.parent].channels.text.splice(channelIndex, 1);\n          delete dataCopy[target.parent].chatData[target.id];\n\n          return dataCopy;\n        });\n\n        if (selectedChannelRef.current?._id === target.id) {\n          setSelectedChannel(null);\n          navigate(`/g/${selectedGroupRef.current.name}`);\n        }\n      }\n\n      function createGroup() {\n        setGroupData((currentData) => {\n          const dataCopy = { ...currentData };\n          dataCopy.push(change.data);\n          dataCopy[target.parent].chatData[target.id] = [];\n          return dataCopy;\n        });\n      }\n\n      function editGroup() {\n        const isKicked = change.extra?.toKick?.includes(localStorage.userId);\n\n        setGroupData((currentData) => {\n          const dataCopy = { ...currentData };\n\n          if (isKicked) delete dataCopy[target.id];\n          else {\n            // move old chat to new group\n            const chatCopy = dataCopy[target.id].chatData;\n            dataCopy[target.id] = change.data;\n            dataCopy[target.id].chatData = chatCopy;\n          }\n\n          return dataCopy;\n        });\n\n        if (selectedGroupRef.current?._id === target.id) {\n          if (isKicked) {\n            setSelectedGroup(null);\n            setSelectedChannel(null);\n            navigate(\"/\");\n          } else {\n            setSelectedGroup(change.data);\n\n            // reroute to updated, depending on if in channel\n            if (selectedChannelRef.current) {\n              navigate(\n                `/g/${change.data.name}/c/${selectedChannelRef.current.name}`\n              );\n            } else {\n              navigate(`/g/${change.data.name}`);\n            }\n          }\n        }\n      }\n\n      function deleteGroup() {\n        setGroupData((currentData) => {\n          const dataCopy = { ...currentData };\n          delete dataCopy[target.id];\n          return dataCopy;\n        });\n\n        if (selectedGroupRef.current?._id === target.id) {\n          clearSelected();\n          navigate(`/`);\n        }\n      }\n\n      function joinedGroup() {\n        setGroupData((currentData) => {\n          const dataCopy = { ...currentData };\n          dataCopy[target.id].members.push(change.extra.user);\n          return dataCopy;\n        });\n        dataHelpers.mergePeers(change.extra.partialPeerData);\n      }\n\n      function leftGroup(params) {\n        setGroupData((currentData) => {\n          const dataCopy = { ...currentData };\n\n          dataCopy[target.id].members = dataCopy[target.id].members.filter(\n            (member) => member._id !== change.extra.userId\n          );\n\n          dataCopy[target.id].administrators = dataCopy[\n            target.id\n          ].members.filter((admin) => admin._id !== change.extra.userId);\n\n          return dataCopy;\n        });\n      }\n\n      // function editMessage() {} // todo\n\n      // function deleteMessage() {} // todo\n\n      if (messages.length > 0) pushFlashMessage(messages); // transfer any messages to context\n\n      if (target.type === \"channel\") {\n        if (change.type === \"create\") createChannel();\n        else if (change.type === \"edit\") editChannel();\n        else if (change.type === \"delete\") deleteChannel();\n      } else if (target.type === \"group\") {\n        if (change.type === \"create\") createGroup();\n        else if (change.type === \"edit\") editGroup();\n        else if (change.type === \"delete\") deleteGroup();\n        else if (change.type === \"join\") joinedGroup();\n        else if (change.type === \"leave\") leftGroup();\n      }\n      // else if (target.type === \"message\") {\n      //   if (change.type === \"edit\") editMessage();\n      //   else if (change.type === \"delete\") deleteMessage();\n      // }\n    });\n\n    socket.on(\"statusChange\", (res) => {\n      peerHelpers.changeStatus({ target: res.target, change: res.change });\n    });\n  }\n\n  const socketInstance = {\n    socket,\n    connectSocket,\n    socketStatus,\n    socketClear,\n  };\n\n  return (\n    <SocketContext.Provider value={socketInstance}>\n      {props.children}\n    </SocketContext.Provider>\n  );\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}